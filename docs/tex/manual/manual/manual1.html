<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>manual</TITLE>
<META NAME="description" CONTENT="manual">
<META NAME="keywords" CONTENT="manual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="manual.css">

</HEAD>

<BODY BGCOLOR="#ffffff"  >

<DIV CLASS="navigation"><!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive" SRC="nx_grp_g.gif"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_g.gif"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev_g.gif">   
<BR>
<BR><BR></DIV>
<!--End of Navigation Panel-->

<P>


<P>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>

<P>
<DIV ALIGN="CENTER">
</DIV>
<P>
<DIV ALIGN="CENTER">ARGONNE NATIONAL LABORATORY
</DIV>
<P>
<DIV ALIGN="CENTER">9700 South Cass Avenue
</DIV>
<P>
<DIV ALIGN="CENTER">Argonne, Illinois  60439
</DIV>
<P>
<DIV ALIGN="CENTER"><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</DIV>
<P>
<DIV ALIGN="CENTER"><BIG CLASS="XLARGE"><B>TAO Users Manual
</B>
</BIG>
</DIV>
<P>
<DIV ALIGN="CENTER"><BR>
<BR>
<BR>
<BR>
</DIV>
<P>
<DIV ALIGN="CENTER"><B>Lois Curfman McInnes 
<BR>Jorge J. Mor&#233; 
<BR>Todd Munson 
<BR>Jason Sarich</B>
</DIV>
<P>
<DIV ALIGN="CENTER"><BR>
<BR>
<BR>
<BR>
</DIV>
<P>
<DIV ALIGN="CENTER">Mathematics and Computer Science Division
</DIV>
<P>
<DIV ALIGN="CENTER"><BR>
<BR>
<BR>
</DIV>
<P>
<DIV ALIGN="CENTER">Technical Report  ANL/MCS-TM-242-Revision 1.10.1
</DIV>
<P>
<DIV ALIGN="CENTER"><BR>
<BR>
<BR>
</DIV>
<P>
<DIV ALIGN="CENTER">This manual is intended for use with TAO version 1.10.1
</DIV>
<P>
<DIV ALIGN="CENTER"><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</DIV>
<P>
<DIV ALIGN="CENTER">September 15, 2011

</DIV>

<P>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>

<P>
This work was supported by the Mathematical, Information,
and Computational Sciences Division subprogram of the
Office of Computational and Technology Research,
U.S. Department of Energy, under Contract W-31-109-Eng-38.

<P>

<BR>

<H2><A NAME="SECTION00100000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL CLASS="TofC">
<LI><A NAME="tex2html146"
  HREF="manual.html#SECTION00200000000000000000">Introduction to TAO</A>
<UL>
<LI><A NAME="tex2html147"
  HREF="manual.html#SECTION00210000000000000000">TAO Design Philosophy</A>
<LI><A NAME="tex2html148"
  HREF="manual.html#SECTION00220000000000000000">Performance Results</A>
</UL><BR>
<LI><A NAME="tex2html149"
  HREF="manual.html#SECTION00300000000000000000">Basic Usage of TAO Solvers</A>
<UL>
<LI><A NAME="tex2html150"
  HREF="manual.html#SECTION00310000000000000000">Initialize and Finalize</A>
<LI><A NAME="tex2html151"
  HREF="manual.html#SECTION00320000000000000000">Creation and Destruction</A>
<LI><A NAME="tex2html152"
  HREF="manual.html#SECTION00330000000000000000">Convergence</A>
<LI><A NAME="tex2html153"
  HREF="manual.html#SECTION00340000000000000000">Viewing Solutions</A>
</UL><BR>
<LI><A NAME="tex2html154"
  HREF="manual.html#SECTION00400000000000000000">TAO Solvers</A>
<UL>
<LI><A NAME="tex2html155"
  HREF="manual.html#SECTION00410000000000000000">Unconstrained Minimization</A>
<UL>
<LI><A NAME="tex2html156"
  HREF="manual.html#SECTION00411000000000000000">Nelder-Mead</A>
<LI><A NAME="tex2html157"
  HREF="manual.html#SECTION00412000000000000000">Limited-Memory, Variable-Metric Method</A>
<LI><A NAME="tex2html158"
  HREF="manual.html#SECTION00413000000000000000">Nonlinear Conjugate Gradient Method</A>
<LI><A NAME="tex2html159"
  HREF="manual.html#SECTION00414000000000000000">Newton Line-Search Method</A>
<LI><A NAME="tex2html160"
  HREF="manual.html#SECTION00415000000000000000">Newton Trust-Region Method</A>
</UL>
<LI><A NAME="tex2html161"
  HREF="manual.html#SECTION00420000000000000000">Bound Constrained Optimization</A>
<UL>
<LI><A NAME="tex2html162"
  HREF="manual.html#SECTION00421000000000000000">Newton Trust Region</A>
<LI><A NAME="tex2html163"
  HREF="manual.html#SECTION00422000000000000000">Gradient Projection-Conjugate Gradient Method</A>
<LI><A NAME="tex2html164"
  HREF="manual.html#SECTION00423000000000000000">Interior Point Newton Algorithm</A>
<LI><A NAME="tex2html165"
  HREF="manual.html#SECTION00424000000000000000">Limited Memory Variable Metric Method</A>
<LI><A NAME="tex2html166"
  HREF="manual.html#SECTION00425000000000000000">KT Method</A>
</UL>
<LI><A NAME="tex2html167"
  HREF="manual.html#SECTION00430000000000000000">Complementarity</A>
<UL>
<LI><A NAME="tex2html168"
  HREF="manual.html#SECTION00431000000000000000">Semismooth Methods</A>
</UL>
</UL><BR>
<LI><A NAME="tex2html169"
  HREF="manual.html#SECTION00500000000000000000">TAO Applications using PETSc</A>
<UL>
<LI><A NAME="tex2html170"
  HREF="manual.html#SECTION00510000000000000000">Header File</A>
<LI><A NAME="tex2html171"
  HREF="manual.html#SECTION00520000000000000000">Create and Destroy</A>
<LI><A NAME="tex2html172"
  HREF="manual.html#SECTION00530000000000000000">Defining Variables</A>
<LI><A NAME="tex2html173"
  HREF="manual.html#SECTION00540000000000000000">Application Context</A>
<LI><A NAME="tex2html174"
  HREF="manual.html#SECTION00550000000000000000">Objective Function and Gradient Routines</A>
<LI><A NAME="tex2html175"
  HREF="manual.html#SECTION00560000000000000000">Hessian Evaluation</A>
<UL>
<LI><A NAME="tex2html176"
  HREF="manual.html#SECTION00561000000000000000">Finite Differences</A>
<LI><A NAME="tex2html177"
  HREF="manual.html#SECTION00562000000000000000">Matrix-Free methods</A>
</UL>
<LI><A NAME="tex2html178"
  HREF="manual.html#SECTION00570000000000000000">Bounds on Variables</A>
<LI><A NAME="tex2html179"
  HREF="manual.html#SECTION00580000000000000000">Complementarity</A>
<LI><A NAME="tex2html180"
  HREF="manual.html#SECTION00590000000000000000">Monitors</A>
<LI><A NAME="tex2html181"
  HREF="manual.html#SECTION005100000000000000000">Linear Solvers</A>
<LI><A NAME="tex2html182"
  HREF="manual.html#SECTION005110000000000000000">Application Solutions</A>
<LI><A NAME="tex2html183"
  HREF="manual.html#SECTION005120000000000000000">Linear Algebra Abstractions</A>
<LI><A NAME="tex2html184"
  HREF="manual.html#SECTION005130000000000000000">Compiling and Linking</A>
<LI><A NAME="tex2html185"
  HREF="manual.html#SECTION005140000000000000000">TAO Applications using PETSc and FORTRAN</A>
<UL>
<LI><A NAME="tex2html186"
  HREF="manual.html#SECTION005141000000000000000">Include Files</A>
<LI><A NAME="tex2html187"
  HREF="manual.html#SECTION005142000000000000000">Error Checking</A>
<LI><A NAME="tex2html188"
  HREF="manual.html#SECTION005143000000000000000">Compiling and Linking Fortran Programs</A>
<LI><A NAME="tex2html189"
  HREF="manual.html#SECTION005144000000000000000">Additional Issues</A>
</UL>
</UL><BR>
<LI><A NAME="tex2html190"
  HREF="manual.html#SECTION00600000000000000000">Advanced Options</A>
<UL>
<LI><A NAME="tex2html191"
  HREF="manual.html#SECTION00610000000000000000">Convergence Tests</A>
<LI><A NAME="tex2html192"
  HREF="manual.html#SECTION00620000000000000000">Line Searches</A>
</UL><BR>
<LI><A NAME="tex2html193"
  HREF="manual.html#SECTION00700000000000000000">Adding a solver</A>
<UL>
<LI><A NAME="tex2html194"
  HREF="manual.html#SECTION00710000000000000000">Adding a Solver to TAO</A>
<LI><A NAME="tex2html195"
  HREF="manual.html#SECTION00720000000000000000">TAO Interface with Solvers</A>
<UL>
<LI><A NAME="tex2html196"
  HREF="manual.html#SECTION00721000000000000000">Solver Routine</A>
<LI><A NAME="tex2html197"
  HREF="manual.html#SECTION00722000000000000000">Creation Routine</A>
<LI><A NAME="tex2html198"
  HREF="manual.html#SECTION00723000000000000000">Destroy Routine</A>
<LI><A NAME="tex2html199"
  HREF="manual.html#SECTION00724000000000000000">SetUp Routine</A>
</UL>
</UL><BR>
<LI><A NAME="tex2html200"
  HREF="manual.html#SECTION00800000000000000000">Index</A>
<LI><A NAME="tex2html201"
  HREF="manual.html#SECTION00900000000000000000">Bibliography</A>
</UL>
<!--End of Table of Contents-->
<P>


<P>

<H1><A NAME="SECTION00110000000000000000">
Preface</A>
</H1>

<P>
The Toolkit for Advanced Optimization (TAO) focuses on the development
of algorithms and software for the solution of large-scale
optimization problems on high-performance architectures.  Areas of
interest include nonlinear least squares, unconstrained and
bound-constrained optimization, and general nonlinear optimization.

<P>
The development of TAO was motivated by the scattered support for
parallel computations and the lack of reuse of external toolkits in
current optimization software.  Our aim is to use object-oriented
techniques to produce high-quality optimization software for a range
of computing environments ranging from serial workstations and laptops
to massively parallel high-performance architectures.  Our design
decisions are strongly motivated by the challenges inherent in the use
of large-scale distributed memory architectures and the reality of
working with large, often poorly structured legacy codes for specific
applications.

<P>
This manual describes the use of TAO.
Since TAO is still under development, changes in usage and
calling sequences may occur.  TAO is fully supported; see the
the web site <TT><A NAME="tex2html1"
  HREF="http://www.mcs.anl.gov/tao">http://www.mcs.anl.gov/tao</A></TT> for information on
contacting the TAO developers.

<P>

<P>

<P>

<H1><A NAME="SECTION00120000000000000000">
Acknowledgments</A>
</H1>

<P>
The initial development of TAO was funded by the ACTS Toolkit Project in
the Office of Advanced Scientific Computing Research, U.S. Department
of Energy. We gratefully acknowledge their support.

<P>
TAO owes much to the developers of PETSc. We have benefitted
from their experience, tools, software, and advice. In many ways, TAO is a 
natural outcome of the PETSc development.
TAO has also benefitted from the work of various researchers
who have provided solvers, test problems, and interfaces.
In particular, we acknowledge

<P>

<UL>
<LI>Lisa Grignon for contributing the least squares examples
<TT>chebyq.c</TT>, <TT>coating.c</TT>  and <TT>enzreac1.c</TT>;
</LI>
<LI>Yurii Zinchenko and Mike Gertz for the interface to
the OOQP solver for quadratic problems with linear constraints;
</LI>
<LI>Liz Dolan for developing the HTML version of the TAO user guide
</LI>
<LI>Boyana Norris for developing prototype CCA-compliant 
optimization component interfaces.
</LI>
<LI>Gabriel Lopez-Calva for integrating ADIC with TAO on Distributed
Array applications and developing examples that use them; and
</LI>
<LI>Jarek Nieplocha, Limin Zhang, and Manojkumar Krishnan for the
interface between Global Arrays and TAO and implemented example
applications.
</LI>
</UL>

<P>
Finally, we thank all TAO users for their comments, bug reports, and
encouragement.

<P>

<P>

<P>

<H1><A NAME="SECTION00200000000000000000"></A>
<A NAME="chapter:introduction"></A><BR>
Introduction to TAO
</H1>

<P>
The Toolkit for Advanced Optimization (TAO) focuses on the design and
implementation of optimization software for the
solution of large-scale optimization applications on high-performance
architectures.  Our approach is motivated by the scattered support for
parallel computations and lack of reuse of linear algebra software in
currently available optimization software.  The TAO design allows the
reuse of toolkits that provide lower-level support (parallel sparse
matrix data structures, preconditioners, solvers), and thus we are
able to build on top of these toolkits instead of having to redevelop
code. The advantages in terms of efficiency and development time are
significant.

<P>
The TAO design philosophy uses object-oriented techniques of data and
state encapsulation, abstract classes, and limited inheritance to
create a flexible optimization toolkit.  This chapter provides a short
introduction to our design philosophy by describing the objects in TAO
and the importance of this design.  Since a major concern in the TAO
project is the performance and scalability of optimization algorithms
on large problems, we also present some performance resuls.

<P>

<H1><A NAME="SECTION00210000000000000000">
TAO Design Philosophy</A>
</H1> 

<P>
The TAO design philosophy place strongs emphasis on the reuse of
external tools where appropriate.  Our design enables bidirectional
connection to lower-level linear algebra support (e.g. parallel sparse
matrix data structures) provided in toolkits such as PETSc
[<A
 HREF="manual.html#petsc">3</A>] [<A
 HREF="manual.html#petsc-user-ref">4</A>,<A
 HREF="manual.html#petsc-web-page">2</A>]
as well as higher-level application
frameworks.  Our design decisions are strongly motivated by the
challenges inherent in the use of large-scale distributed memory
architectures and the reality of working with large and often poorly
structured legacy codes for specific applications.  Figure
<A HREF="#tao:design">1.1</A> illustrates how the TAO software works with external
libraries and application code.

<P>

<DIV ALIGN="CENTER"><A NAME="tao:design"></A><A NAME="216"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1.1:</STRONG>
TAO Design</CAPTION>
<TR><TD><IMG
 WIDTH="637" HEIGHT="403" BORDER="0"
 SRC="img3.gif"
 ALT="\begin{figure}\centerline{\epsfysize=3.5in \epsfbox{taofig.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>
The TAO solvers use four fundamental objects to define and solve
optimization problems: vectors, index sets, matrices, and linear
solvers.  The concepts of vectors and matrices are standard, while an
index set refers to a set of integers used to identify particular
elements of vectors or matrices.  An optimization algorithm is a
sequence of well defined operations on these objects.  These
operations include vector sums, inner products, and matrix-vector
multiplication.  TAO makes no assumptions about the representation of
these objects by passing pointers to data-structure-neutral objects
for the execution of these numerical operations.

<P>
With sufficiently flexible abstract interfaces, TAO can support a
variety of implementations of data structures and algorithms.  These
abstractions allow us to more easily experiment with a range of
algorithmic and data structure options for realistic problems, such as
within this case study.  Such capabilities are critical for making
high-performance optimization software adaptable to the continual
evolution of parallel and distributed architectures and the research
community's discovery of new algorithms that exploit their features.

<P>
Our current TAO implementation uses the parallel system
infrastructure and linear algebra objects offered by PETSc,
which uses MPI [<A
 HREF="manual.html#using-mpi">13</A>] for all interprocessor communication.
The PETSc package supports objects for vectors, matrices, index 
sets, and linear solvers.

<P>
The TAO design philosophy eliminates some of the barriers in using
independently developed software components by accepting data that is
independent of representation and calling sequence written for
particular data formats.  The user can initialize an application with
external frameworks, provide function information to a TAO solver, and
call TAO to solve the application problem.

<P>
The use of abstractions for matrices and vectors in TAO optimization
software also enables us to leverage automatic differentiation
technology to facilitate the parallel computation of gradients and
Hessians needed within optimization algorithms.  We have demonstrated
the viability of this approach through preliminary interfacing between
TAO solvers and the automatic differentiation tools ADIFOR and ADIC.
We are currently working on developing TAO interfaces that use special
problem features (for example, partial separability, stencil
information) in automatic differentiation computations.

<P>

<H1><A NAME="SECTION00220000000000000000">
Performance Results</A>
</H1>

<P>
A major concern in the TAO project is the performance and scalability
of optimization algorithms on large problems.  In this section we
focus on the GPCG (gradient projection, conjugate gradient) algorithm
for the solution of bound-constrained convex quadratic programming
problems.  Originally developed by Mor&#233; and Toraldo
[<A
 HREF="manual.html#more-toraldo">20</A>], the GPCG algorithm was designed for large-scale
problems but had only been implemented for a single processor.  GPCG
combines the advantages of the identification properties of the
gradient projection method with the finite termination properties of
the conjugate gradient method.  Moreover, the performance of the
TAO implementation on large optimization problems is noteworthy.

<P>

<DIV ALIGN="CENTER"><A NAME="dpjb"></A><A NAME="224"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1.2:</STRONG>
The journal bearing problem with <SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img5.gif"
 ALT="$\epsilon$"></SPAN> = 0.9</CAPTION>
<TR><TD><IMG
 WIDTH="416" HEIGHT="346" BORDER="0"
 SRC="img6.gif"
 ALT="\begin{figure}\centerline{\epsfysize=3.0in \epsfbox{pjb.eps}}\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>
We illustrate the performance of the GPCG algorithm by 
presenting results for a journal bearing problem
with over 2.5 million variables.
The journal bearing problem
is a finite element approximation to a variational problem 
over a rectangular two-dimensional grid.  A
grid with <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img7.gif"
 ALT="$1600$"></SPAN> points in each direction, for example, is formulated
as a bound constrained quadratic problem with <!-- MATH
 $1600^2=2,560,000$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="146" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="img8.gif"
 ALT="$1600^2=2,560,000$"></SPAN>
variables.
The triangulation of the grid results in a matrix that has the
usual five diagonal nonzero structure that arises
from a difference approximation to the Laplacian operator.
The journal bearing problem contains an eccentricity parameter,
<!-- MATH
 $\varepsilon \in (0,1)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="72" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img9.gif"
 ALT="$\varepsilon \in (0,1)$"></SPAN>, that influences the number of active
variables at the solution and the difficulty in solving it.
Figure <A HREF="#dpjb">1.2</A> shows the solution of the journal bearing problem
for <!-- MATH
 $\varepsilon = 0.9$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="58" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img10.gif"
 ALT="$ \varepsilon = 0.9 $"></SPAN>. The steep gradient in the solution
makes this problem a difficult benchmark.

<P>
The performance results in Table <A HREF="#flops">1.1</A> are noteworthy is several
ways.  First of all, the number of faces visited by GPCG is remarkably
small.  Other strategies can lead to a large number of gradient
projection iterates, but the GPCG algorithm is remarkably efficient.
Another interesting aspect of these results is that due to the low
memory requirements of iterative solvers, we were able to solve these
problems with only <SPAN CLASS="MATH"><IMG
 WIDTH="45" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img11.gif"
 ALT="$ p = 8 $"></SPAN> processors.  Strategies that rely on
direct solvers are likely to need significantly more storage, and thus
more processors.  Finally, these results show that the GPCG
implementation has excellent efficiency.  For example, the efficiency
of GPCG with respect to <SPAN CLASS="MATH"><IMG
 WIDTH="45" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img12.gif"
 ALT="$ p = 8 $"></SPAN> processors ranges between <SPAN CLASS="MATH"><IMG
 WIDTH="36" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img13.gif"
 ALT="$ 70\% $"></SPAN>
and <SPAN CLASS="MATH"><IMG
 WIDTH="45" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img14.gif"
 ALT="$ 100\% $"></SPAN> when <!-- MATH
 $\varepsilon = 0.1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="58" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img15.gif"
 ALT="$ \varepsilon = 0.1 $"></SPAN>.  This sustained efficiency
is remarkable since the GPCG algorithm is solving a sequence of linear
problems with a coefficient matrix set to the submatrix of the Hessian
matrix with respect to the free variables for the current iterate.
Thus, our implementation's repartitioning of submatrices effectively
deals with the load-balancing problem that is inherent in the GPCG
algorithm.

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="255"></A>
<TABLE>
<CAPTION><STRONG>Table 1.1:</STRONG>
Performance of GPCG on the journal bearing problem
with <!-- MATH
 $2.56 \cdot 10^6$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="72" HEIGHT="21" ALIGN="BOTTOM" BORDER="0"
 SRC="img22.gif"
 ALT="$ 2.56 \cdot 10^6 $"></SPAN> variables.</CAPTION>
<TR><TD><DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1" ALIGN="CENTER">
<TR><TD ALIGN="CENTER" COLSPAN=1><SPAN><SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img16.gif"
 ALT="$ \varepsilon $"></SPAN></SPAN></TD>
<TD ALIGN="CENTER" COLSPAN=1><SPAN><SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img17.gif"
 ALT="$ p $"></SPAN></SPAN></TD>
<TD ALIGN="CENTER" COLSPAN=1><SPAN>faces</SPAN></TD>
<TD ALIGN="CENTER" COLSPAN=1><SPAN><SPAN CLASS="MATH"><IMG
 WIDTH="36" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img18.gif"
 ALT="$n_{CG}$"></SPAN></SPAN></TD>
<TD ALIGN="CENTER" COLSPAN=1><SPAN>time</SPAN></TD>
<TD ALIGN="CENTER" COLSPAN=1><SPAN><SPAN CLASS="MATH"><IMG
 WIDTH="32" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img19.gif"
 ALT="$t_{CG}$"></SPAN>%</SPAN></TD>
<TD ALIGN="CENTER" COLSPAN=1><SPAN><SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img20.gif"
 ALT="$ \cal E $"></SPAN></SPAN></TD>
</TR>
<TR><TD ALIGN="CENTER">0.1</TD>
<TD ALIGN="RIGHT">8</TD>
<TD ALIGN="CENTER">46</TD>
<TD ALIGN="CENTER">431</TD>
<TD ALIGN="RIGHT">7419</TD>
<TD ALIGN="CENTER">86</TD>
<TD ALIGN="RIGHT">100</TD>
</TR>
<TR><TD ALIGN="CENTER">0.1</TD>
<TD ALIGN="RIGHT">16</TD>
<TD ALIGN="CENTER">45</TD>
<TD ALIGN="CENTER">423</TD>
<TD ALIGN="RIGHT">3706</TD>
<TD ALIGN="CENTER">83</TD>
<TD ALIGN="RIGHT">100</TD>
</TR>
<TR><TD ALIGN="CENTER">0.1</TD>
<TD ALIGN="RIGHT">32</TD>
<TD ALIGN="CENTER">45</TD>
<TD ALIGN="CENTER">427</TD>
<TD ALIGN="RIGHT">2045</TD>
<TD ALIGN="CENTER">82</TD>
<TD ALIGN="RIGHT">91</TD>
</TR>
<TR><TD ALIGN="CENTER">0.1</TD>
<TD ALIGN="RIGHT">64</TD>
<TD ALIGN="CENTER">45</TD>
<TD ALIGN="CENTER">427</TD>
<TD ALIGN="RIGHT">1279</TD>
<TD ALIGN="CENTER">82</TD>
<TD ALIGN="RIGHT">73</TD>
</TR>
<TR><TD ALIGN="CENTER">0.9</TD>
<TD ALIGN="RIGHT">8</TD>
<TD ALIGN="CENTER">37</TD>
<TD ALIGN="CENTER">105</TD>
<TD ALIGN="RIGHT">2134</TD>
<TD ALIGN="CENTER">70</TD>
<TD ALIGN="RIGHT">100</TD>
</TR>
<TR><TD ALIGN="CENTER">0.9</TD>
<TD ALIGN="RIGHT">16</TD>
<TD ALIGN="CENTER">37</TD>
<TD ALIGN="CENTER">103</TD>
<TD ALIGN="RIGHT">1124</TD>
<TD ALIGN="CENTER">71</TD>
<TD ALIGN="RIGHT">95</TD>
</TR>
<TR><TD ALIGN="CENTER">0.9</TD>
<TD ALIGN="RIGHT">32</TD>
<TD ALIGN="CENTER">38</TD>
<TD ALIGN="CENTER">100</TD>
<TD ALIGN="RIGHT">618</TD>
<TD ALIGN="CENTER">69</TD>
<TD ALIGN="RIGHT">86</TD>
</TR>
<TR><TD ALIGN="CENTER">0.9</TD>
<TD ALIGN="RIGHT">64</TD>
<TD ALIGN="CENTER">38</TD>
<TD ALIGN="CENTER">99</TD>
<TD ALIGN="RIGHT">397</TD>
<TD ALIGN="CENTER">68</TD>
<TD ALIGN="RIGHT">67</TD>
</TR>
</TABLE>

<A NAME="flops"></A>
</DIV></TD></TR>
</TABLE>
</DIV><P></P><BR>

<P>
An important aspect of our results that is not
apparent from Table <A HREF="#flops">1.1</A> is that 
for these results we were able to experiment easily 
with all the preconditioners offered by PETSc.
In particular, we were able to compare the diagonal Jacobi
preconditioner with block Jacobi and overlapping additive Schwarz
preconditioners that use a zero-fill ILU solver in each block.  We
also experimented with a parallel zero-fill incomplete Cholesky preconditioner
provided by a PETSc interface to the BlockSolve95&nbsp;[<A
 HREF="manual.html#bs-user-ref">15</A>]
package of Jones and
Plassmann.  Interestingly enough, the diagonal Jacobi preconditioner
achieved better performance on this problem.

<P>

<P>

<P>

<H1><A NAME="SECTION00300000000000000000"></A>
<A NAME="chapter:tao_solver"></A><BR>
Basic Usage of TAO Solvers
</H1>

<P>
TAO contains unconstrained minimization, bound constrained minimization, 
and nonlinear complementarity solvers.
The structure of these problems can differ significantly, 
but TAO has a similar interface to all of its solvers.  
Routines that most solvers have in common will be discussed in 
this chapter.
A complete list of options can be found by consulting the manual pages.
Many of the options can also be set at the command line.  These options
can also be found in manual pages or by
running a program with the <TT>-help</TT> option.

<P>

<H1><A NAME="SECTION00310000000000000000">
Initialize and Finalize</A>
</H1>
The first TAO routine in any application should be <TT>TaoInitialize()</TT>.
Most TAO programs begin with a call to
<A NAME="690"></A>
<PRE>
   info = TaoInitialize(int *argc,char ***argv,char *file_name, 
                        char *help_message);
</PRE>

This command initializes TAO, as well as MPI, PETSc, and other packages
to which TAO applications may link (if these have not yet
been initialized elsewhere).  
In particular, the arguments <TT>argc</TT> and 
<TT>argv</TT> are the command line arguments delivered in all C and C++
programs; these arguments initialize the options database.  
<A NAME="691"></A> The argument <TT>file_name</TT>
optionally indicates an alternative name for an options file, which by
default is called <TT>.petscrc</TT> and resides in the user's home directory.

<P>
One of the last routines<A NAME="692"></A> that all TAO programs should 
call is 
<PRE>
   info = TaoFinalize();
</PRE>

This routine finalizes TAO and any other libraries that may have been
initialized during the <TT>TaoInitialize()</TT> phase.
For example, <TT>TaoFinalize()</TT>
calls <TT>MPI_Finalize()</TT> if <TT>TaoInitialize()</TT>
began MPI. If MPI was initiated externally from TAO (by either
the user or another software package), then the user is
responsible for calling <TT>MPI_Finalize()</TT>. 

<P>

<H1><A NAME="SECTION00320000000000000000">
Creation and Destruction</A>
</H1>

<P>
A TAO solver can be created with
the command 
<A NAME="693"></A>
<PRE>
   info = TaoCreate(MPI_Comm comm,TaoMethod method,TAO_SOLVER *newsolver);
</PRE>

The first argument in this routine is an MPI communicator indicating which
processes are involved in the solution process.  In
most cases, this should be set to <TT>MPI_COMM_WORLD</TT>.
The second argument in this creation routine 
specifies the default method that should be be used to
solve the optimization problem.  
The third argument in <TT>TaoCreate()</TT> is a pointer to a TAO solver
object.  This routine creates the object and returns it to the user.
The TAO object is then to be used in all TAO routines.

<P>
The various types of TAO solvers and the flags that identify them 
will be discussed in the following chapters.
The solution method should be carefully chosen depending upon
the problem that is being solved.  Some solvers, for instance, are meant for
problems with no constraints, while other solvers acknowledge constraints
in the problem and solve them accordingly.
The user must also be aware of the derivative information that is available.
Some solvers require second-order information, while other solvers require
only gradient or function information.
The <TT>TaoMethod</TT> can also be set to <TT>TAO_NULL</TT> in the 
<TT>TaoCreate()</TT> routine if the user selects a method at runtime using
the options database.
The command line option <TT>-tao_method</TT> followed by an TAO method
will override any method specified by the second argument.
The command line option <TT>-tao_method tao_lmvm</TT>, for instance,
will specify the limited memory variable metric method for unconstrained
optimization.  Note that the <TT>TaoMethod</TT> variable is a string that requires
quotation marks in an application program, but quotation marks are not required
at the command line.
The method that TAO uses to solve an optimization problem can be changed at a later point
in the program with the command
<A NAME="694"></A> <TT>TaoSetMethod()</TT>, whose
arguments are a TAO solver
and a string that uniquely identifies a method for solving the problem.

<P>
Each TAO solver that has been created should also be destroyed using
the command 
<A NAME="695"></A>
<PRE>
   info = TaoDestroy(TAO_SOLVER solver);
</PRE>

This routine frees the internal data structures used by the solver.

<P>

<H1><A NAME="SECTION00330000000000000000"></A><A NAME="sec:customize"></A><BR>
Convergence
</H1>

<P>
Although TAO and its solvers set default parameters 
that are useful
for many problems, it may be necessary for the user to modify these
parameters to change the behavior and convergence of various algorithms.

<P>
One convergence criterion for most algorithms concerns the
of digits of accuracy needed in the solution.  In particular,
one convergence test employed by TAO attempts to stop when
the error in the constraints is less than <!-- MATH
 $\epsilon_{crtol}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="40" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img23.gif"
 ALT="$\epsilon_{crtol}$"></SPAN>,
 and either
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
\frac{ |f(X) - f(X^*)|}{ |f(X)| + 1} \leq \epsilon_{frtol}
\;\textnormal{or}\;
f(X) - f(X^*)  \leq \epsilon_{fatol},
\end{displaymath}
 -->

<IMG
 WIDTH="381" HEIGHT="48" BORDER="0"
 SRC="img24.gif"
 ALT="\begin{displaymath}\frac{ \vert f(X) - f(X^*)\vert}{ \vert f(X)\vert + 1} \leq \...
...rtol}
\;\textnormal{or}\;
f(X) - f(X^*) \leq \epsilon_{fatol}, \end{displaymath}">
</DIV><BR CLEAR="ALL">
<P></P>
where <SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img25.gif"
 ALT="$X^*$"></SPAN> is the current approximation to <SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img26.gif"
 ALT="$X$"></SPAN>.
TAO estimates <SPAN CLASS="MATH"><IMG
 WIDTH="112" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img27.gif"
 ALT="$f(X) - f(X^*)$"></SPAN> with either 
the square of the norm of the gradient or the duality gap.
A relative tolerance of <!-- MATH
 $\epsilon_{frtol}=0.01$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="96" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img28.gif"
 ALT="$\epsilon_{frtol}=0.01$"></SPAN> indicates that two
significant digits are desired in the objective function.
Each solver sets its own  convergence tolerances, but they can
be changed using the routine
<TT>TaoSetTolerances()</TT><A NAME="696"></A> <A NAME="697"></A>. 
Another set of convergence tolerances can be set with 
<TT>TaoSetGradientTolerances()</TT>.<A NAME="698"></A>
These tolerances terminate the solver when the norm of the gradient function
(or Lagrangian function for bound-constrained problems)
is sufficiently close to zero.

<P>
Other stopping criteria include a minimum trust region radius or 
a maximum number of iterations.  These parameters can be set with
the routines <TT>TaoSetTrustRegionTolerance()</TT><A NAME="699"></A><A NAME="700"></A>
and <TT>TaoSetMaximumIterates()</TT><A NAME="701"></A>.
Similarly, a maximum number of function evaluations can be set 
with the command 
<TT>TaoSetMaximumFunctionEvaluations()</TT>
<A NAME="702"></A>.

<P>

<H1><A NAME="SECTION00340000000000000000">
Viewing Solutions</A>
</H1>

<P>
The routine
<PRE>
   int TaoSolveApplication(TAO_APPLICATION, TAO_SOLVER);
</PRE>

will apply the solver to the application that has been created by the user.

<P>
To see parameters and performance statistics for the solver, the
routine
<PRE>
   int TaoView(TAO_SOLVER);
</PRE>
can be used.  This routine will display to standard output the number
of function evaluations need by the solver and other information
specific to the solver.

<P>
The progress of the optimization solver can be monitored with
the runtime option <TT>-tao_monitor</TT>.  Although monitoring routines
can be customized, the default monitoring routine will print out 
several relevant statistics to the screen.

<P>
The user also has access to information about the current solution.
The current iteration number, objective function value, gradient
norm, infeasibility norm, and step length 
can be retrieved with the command 
<A NAME="703"></A>
<PRE>
   int TaoGetSolutionStatus(TAO_SOLVER tao, int* iterate, double* f, 
                            double* gnorm, double *cnorm, double *xdiff, 
                            TaoTerminateReason *reason)
</PRE>

The last argument returns
a code that indicates the reason that the solver terminated.  Positive 
numbers indicate that a solution has been found, while negative numbers
indicate a failure.  A list of reasons can be found in the manual page
for <TT>TaoGetTerminationReason()</TT>.

<P>
The user set
vectors containing the solution and gradient before solving
the problem, but pointers to these vectors can also be retrieved with the
commands <TT>TaoGetSolution()</TT><A NAME="704"></A>
and <TT>TaoGetGradient()</TT><A NAME="705"></A>.  
Dual variables and other relevant information are also available. 
This information can be obtained during
user-defined routines such as a function evaluation and customized
monitoring routine, or after the solver has terminated.

<P>

<P>

<P>

<H1><A NAME="SECTION00400000000000000000">
TAO Solvers</A>
</H1>

<P>

<H1><A NAME="SECTION00410000000000000000"></A>
<A NAME="chapter:unconstrained"></A><BR>
Unconstrained Minimization
</H1>
Unconstrained minimization is used to minimize a function of many variables
without any constraints on the variables, such as bounds.  The methods 
available in TAO for solving these problems can be classified according
to the amount of derivative information required:

<OL>
<LI>Function evaluation only - Nelder-Mead method (<TT>tao_nm</TT>)
</LI>
<LI>Function and gradient evaluations - limited-memory, variable-metric 
method (<TT>tao_lmvm</TT>) and nonlinear conjugate gradient method 
(<TT>tao_cg</TT>)
</LI>
<LI>Function, gradient, and Hessian evaluations - Newton line-search 
method (<TT>tao_nls</TT>) and Newton trust-region method (<TT>tao_ntr</TT>)
</LI>
</OL>
The best method to use depends on the particular problem being solved
and the accuracy required in the solution.  If a Hessian evaluation 
routine is available, then the Newton line-search and Newton trust-region 
methods will be the best performers.  When a Hessian evaluation routine
is not available, then the limited-memory, variable-metric method is 
likely to perform best.  The Nelder-Mead method should be used only
as a last resort when no gradient information is available.

<P>
Each solver has a set of options associated with it that can be set with 
command line arguments.  A brief description of these algorithms and the 
associated options are discussed in this chapter.

<P>

<H2><A NAME="SECTION00411000000000000000">
Nelder-Mead</A>
</H2>
The Nelder-Mead algorithm [<A
 HREF="manual.html#nelder.mead:simplex">24</A>] is a direct search method for finding a local
minimum of a function <SPAN CLASS="MATH"><IMG
 WIDTH="38" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img29.gif"
 ALT="$f(x)$"></SPAN>.  This algorithm does not require any gradient or Hessian 
information of <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.gif"
 ALT="$f$"></SPAN>, and therefore has some expected advantages and disadvantages compared
to the other TAO solvers.  The obvious advantage is that it is easier to write an 
application when no derivatives need to be calculated.  The downside is that this algorithm can
be very slow to converge or can even stagnate, and performs poorly for large numbers of variables.

<P>
This solver keeps a set of <SPAN CLASS="MATH"><IMG
 WIDTH="50" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.gif"
 ALT="$N+1$"></SPAN> sorted vectors <!-- MATH
 ${x_1,x_2,\ldots,x_{N+1}}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="126" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img32.gif"
 ALT="${x_1,x_2,\ldots,x_{N+1}}$"></SPAN> and their corresponding 
objective function values <!-- MATH
 $f_1 \leq f_2 \leq \ldots \leq f_{N+1}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="165" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img33.gif"
 ALT="$f_1 \leq f_2 \leq \ldots \leq f_{N+1}$"></SPAN>.  At each iteration, <SPAN CLASS="MATH"><IMG
 WIDTH="44" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.gif"
 ALT="$x_{N+1}$"></SPAN> is removed from
the set and replaced with 
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
x(\mu) = (1+\mu) \frac{1}{N} \sum_{i=1}^N x_i - \mu x_{N+1},
\end{displaymath}
 -->

<IMG
 WIDTH="253" HEIGHT="62" BORDER="0"
 SRC="img35.gif"
 ALT="\begin{displaymath}
x(\mu) = (1+\mu) \frac{1}{N} \sum_{i=1}^N x_i - \mu x_{N+1},
\end{displaymath}">
</DIV><BR CLEAR="ALL">
<P></P>  

<P>
where <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img36.gif"
 ALT="$\mu$"></SPAN> can be one of <!-- MATH
 ${\mu_0,2\mu_0,\frac{1}{2}\mu_0,-\frac{1}{2}\mu_0}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="143" HEIGHT="40" ALIGN="MIDDLE" BORDER="0"
 SRC="img37.gif"
 ALT="${\mu_0,2\mu_0,\frac{1}{2}\mu_0,-\frac{1}{2}\mu_0}$"></SPAN> depending upon the values of 
each possible <SPAN CLASS="MATH"><IMG
 WIDTH="62" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.gif"
 ALT="$f(x(\mu))$"></SPAN>.

<P>
The algorithm terminates when the residual  <SPAN CLASS="MATH"><IMG
 WIDTH="80" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img39.gif"
 ALT="$f_{N+1} - f_1$"></SPAN> becomes sufficiently small.  Because of 
the way new vectors can be added to the sorted set, 
the minimum function value and/or the residual may not be impacted at each iteration.

<P>
There are two options that can be set specifically for the Nelder-Mead algorithm,
<TT>-tao_nm_lamda &lt;value&gt;</TT> sets the initial set of vectors (<SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img40.gif"
 ALT="$x_0$"></SPAN> plus 
<TT>value</TT> in each cartesion direction), the default value is <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img41.gif"
 ALT="$1$"></SPAN>.  
<TT>tao_nm_mu &lt;value&gt;</TT> sets the value of <SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.gif"
 ALT="$\mu_0$"></SPAN>, 
the default is <SPAN CLASS="MATH"><IMG
 WIDTH="54" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img43.gif"
 ALT="$\mu_0=1$"></SPAN>.

<P>

<H2><A NAME="SECTION00412000000000000000"></A><A NAME="1356"></A><A NAME="1357"></A><BR>
Limited-Memory, Variable-Metric Method
</H2>

<P>
The limited-memory, variable-metric method solves the system of equations
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
H_k d_k = -\nabla f(x_k),
\end{displaymath}
 -->

<IMG
 WIDTH="137" HEIGHT="31" BORDER="0"
 SRC="img44.gif"
 ALT="\begin{displaymath}
H_k d_k = -\nabla f(x_k),
\end{displaymath}">
</DIV><BR CLEAR="ALL">
<P></P>
where <SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img45.gif"
 ALT="$H_k$"></SPAN> is a positive definite approximation to the Hessian matrix 
obtained by using the BFGS update formula with a limited number of 
previous iterates and gradient evaluations.  The inverse of <SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img46.gif"
 ALT="$H_k$"></SPAN> can 
readily be applied to obtain the direction <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img47.gif"
 ALT="$d_k$"></SPAN>.  Having obtained the 
direction, a Mor&#233;-Thuente line search is applied to compute a step
length, <SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img48.gif"
 ALT="$\tau_k$"></SPAN>, that approximately solves the one-dimensional 
optimization problem
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
\min_\tau f(x_k + \tau d_k).
\end{displaymath}
 -->

<IMG
 WIDTH="125" HEIGHT="39" BORDER="0"
 SRC="img49.gif"
 ALT="\begin{displaymath}
\min_\tau f(x_k + \tau d_k).
\end{displaymath}">
</DIV><BR CLEAR="ALL">
<P></P>
The current iterate and Hessian approximation are updated and the process
is repeated until the method converges.  This algorithm is the default 
unconstrained minimization solver and can be selected using the 
TaoMethod <TT>tao_lmvm</TT>.  For best efficiency, function and gradient 
evaluations should be performed simultaneously when using this algorithm.

<P>
The primary factors determining the behavior of this algorithm are the 
number of vectors stored for the Hessian approximation and the scaling matrix
used when computing the direction.  The number of vectors stored can be set
with the command line argument <TT>-tao_lmm_vectors &lt;int&gt;</TT>; <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img50.gif"
 ALT="$5$"></SPAN> is the 
default 
value.  Increasing the number of vectors results in a better Hessian 
approximation and can decrease the number of iterations required to compute
a solution to the optimization problem.  However, as the number of vectors
increases, more memory is consumed and each direction calculation takes
longer to compute.  Therefore, a trade off must be made between the 
quality of the Hessian approximation, the memory requirements, and
the time to compute the direction.

<P>
During the computation of the direction, the inverse of an initial 
Hessian approximation <SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img51.gif"
 ALT="$H_{0,k}$"></SPAN> is applied.  The choice of <SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img52.gif"
 ALT="$H_{0,k}$"></SPAN>
has a significant impact on the quality of the direction obtained
and can result in a decrease in the number of function and gradient 
evaluations required to solve the optimization problem.  However,
the calculation of <SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img53.gif"
 ALT="$H_{0,k}$"></SPAN> at each iteration can have a significant 
impact on the time required to update the limited-memory BFGS 
approximation and the cost of obtaining the direction.  By default, 
<SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img54.gif"
 ALT="$H_{0,k}$"></SPAN> is a diagonal matrix obtained from the diagonal entries
of a Broyden approximation to the Hessian matrix.  The calculation
of <SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img55.gif"
 ALT="$H_{0,k}$"></SPAN> can be modified with the command line argument 
<TT>-tao_lmm_scale_type &lt;none,scalar,broyden&gt;</TT>.  Each scaling 
method is described below.  The <TT>scalar</TT> and <TT>broyden</TT> 
techniques are inspired by [].

<P>
<DL>
<DT><STRONG><TT>none</TT></STRONG></DT>
<DD>This scaling method uses the identity matrix as 
<SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img56.gif"
 ALT="$H_{0,k}$"></SPAN>.  No extra computations are required when obtaining the 
search direction or updating the Hessian approximation.  However, 
the number of functions and gradient evaluations required to converge
to a solution is typically much larger than the number required when 
using other scaling methods.
</DD>
<DT><STRONG><TT>scalar</TT></STRONG></DT>
<DD>This scaling method uses a multiple of the identity 
matrix as <SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img57.gif"
 ALT="$H_{0,k}$"></SPAN>.  The scalar value <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img58.gif"
 ALT="$\sigma$"></SPAN> is chosen by solving the 
one-dimensional optimization problem
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
\min_\sigma \|\sigma^\alpha Y - \sigma^{\alpha - 1} S\|_F^2,
\end{displaymath}
 -->

<IMG
 WIDTH="169" HEIGHT="39" BORDER="0"
 SRC="img59.gif"
 ALT="\begin{displaymath}
\min_\sigma \Vert\sigma^\alpha Y - \sigma^{\alpha - 1} S\Vert _F^2,
\end{displaymath}">
</DIV><BR CLEAR="ALL">
<P></P>
where <!-- MATH
 $\alpha \in [0,1]$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="71" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img60.gif"
 ALT="$\alpha \in [0,1]$"></SPAN> is given, and <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img61.gif"
 ALT="$S$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img62.gif"
 ALT="$Y$"></SPAN> are the matrices of 
past iterate and gradient information required by the limited-memory
BFGS update formula.  The optimal value for <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img63.gif"
 ALT="$\sigma$"></SPAN> can be written
down explicitly.  This choice of <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img64.gif"
 ALT="$\sigma$"></SPAN> attempts to satisfy the 
secant equation <SPAN CLASS="MATH"><IMG
 WIDTH="63" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img65.gif"
 ALT="$\sigma Y = S$"></SPAN>.  Since this equation cannot typically
be satisfied by a scalar, a least norm solution is computed.  The amount 
of past iterate and gradient information used is set by the command line 
argument <TT>tao_lmm_scalar_history &lt;int&gt;</TT>, which must be less than 
or equal to the number of vectors kept for the BFGS approximation.  
The default value is 5.  The choice for <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img66.gif"
 ALT="$\alpha$"></SPAN> is made with the command 
line argument <TT>tao_lmm_scalar_alpha &lt;double&gt;</TT>; <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img67.gif"
 ALT="$1$"></SPAN> is the default
value.  This scaling method offers a good compromise between no scaling 
and <TT>broyden</TT> scaling.
</DD>
<DT><STRONG><TT>broyden</TT></STRONG></DT>
<DD>This scaling method uses a positive-definite diagonal 
matrix obtained from the diagonal entries of the Broyden approximation to 
the Hessian for the scaling matrix.  The Broyden approximation is a 
family of approximations parametrized by a constant <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img68.gif"
 ALT="$\phi$"></SPAN>; <SPAN CLASS="MATH"><IMG
 WIDTH="46" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img69.gif"
 ALT="$\phi = 0$"></SPAN> 
gives the BFGS formula and <SPAN CLASS="MATH"><IMG
 WIDTH="46" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img70.gif"
 ALT="$\phi = 1$"></SPAN> gives the DFP formula.  The value 
of <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img71.gif"
 ALT="$\phi$"></SPAN> is set with the command line argument 
<TT>-tao_lmm_broyden_phi &lt;double&gt;</TT>.  The default value for <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img72.gif"
 ALT="$\phi$"></SPAN> 
is <SPAN CLASS="MATH"><IMG
 WIDTH="44" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img73.gif"
 ALT="$0.125$"></SPAN>.  This scaling method requires the most computational effort 
of available choices, but typically results in a significant reduction 
in the number of function and gradient evaluations taken to compute a 
solution.
</DD>
</DL>

<P>
An additional rescaling of the diagonal matrix can be applied to further
improve performance when using the <TT>broyden</TT> scaling method.  The
rescaling method can be set with the command line argument 
<TT>-tao_lmm_rescale_type &lt;none,scalar,gl&gt;</TT>; <TT>scalar</TT> is the 
default rescaling method.  The rescaling method applied can have a large 
impact on the number of function and gradient evaluations necessary to 
compute a solution to the optimization problem, but increases the time
required to update the BFGS approximation.  Each rescaling method is 
described below.  These techniques are inspired by [].

<P>
<DL>
<DT><STRONG><TT>none</TT></STRONG></DT>
<DD>This rescaling method does not modify the diagonal scaling
matrix.
</DD>
<DT><STRONG><TT>scalar</TT></STRONG></DT>
<DD>This rescaling method chooses a scalar value <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img74.gif"
 ALT="$\sigma$"></SPAN> by 
solving the one-dimensional optimization problem
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
\min_\sigma \|\sigma^\alpha H_{0,k}^{\beta} Y - \sigma^{\alpha - 1} H_{0,k}^{\beta - 1} S\|_F^2,
\end{displaymath}
 -->

<IMG
 WIDTH="244" HEIGHT="39" BORDER="0"
 SRC="img75.gif"
 ALT="\begin{displaymath}
\min_\sigma \Vert\sigma^\alpha H_{0,k}^{\beta} Y - \sigma^{\alpha - 1} H_{0,k}^{\beta - 1} S\Vert _F^2,
\end{displaymath}">
</DIV><BR CLEAR="ALL">
<P></P>
where <!-- MATH
 $\alpha \in [0,1]$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="71" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img76.gif"
 ALT="$\alpha \in [0,1]$"></SPAN> and <!-- MATH
 $\beta \in [0,1]$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="71" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img77.gif"
 ALT="$\beta \in [0,1]$"></SPAN> are given, <SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img78.gif"
 ALT="$H_{0,k}$"></SPAN> is the 
positive-definite diagonal scaling matrix computed by using the Broyden 
update, and <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img79.gif"
 ALT="$S$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img80.gif"
 ALT="$Y$"></SPAN> are the matrices of past iterate and gradient
information required by the limited-memory BFGS update formula.  This 
choice of <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img81.gif"
 ALT="$\sigma$"></SPAN> attempts to satisfy the secant equation 
<!-- MATH
 $\sigma H_{0,k} Y = S$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="97" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img82.gif"
 ALT="$\sigma H_{0,k} Y = S$"></SPAN>.  Since this equation cannot typically be satisfied 
by a scalar, a least norm solution is computed.  The scaling matrix used is 
then <!-- MATH
 $\sigma H_{0,k}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="48" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img83.gif"
 ALT="$\sigma H_{0,k}$"></SPAN>.  The amount of past iterate and gradient information 
used is set by the command line argument 
<TT>tao_lmm_rescale_history &lt;int&gt;</TT>, which must be less than or equal
to the number of vectors kept for the BFGS approximation.  The default value 
is 5.  The choice for <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img84.gif"
 ALT="$\alpha$"></SPAN> is made with the command
line argument <TT>tao_lmm_rescale_alpha &lt;double&gt;</TT>; <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img85.gif"
 ALT="$1$"></SPAN> is the default
value.  The choice for <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img86.gif"
 ALT="$\beta$"></SPAN> is made with the command line argument 
<TT>tao_lmm_rescale_beta &lt;double&gt;</TT>; <SPAN CLASS="MATH"><IMG
 WIDTH="26" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img87.gif"
 ALT="$0.5$"></SPAN> is the default value.
</DD>
<DT><STRONG><TT>gl</TT></STRONG></DT>
<DD>This scaling method is the same as the <TT>scalar</TT> rescaling 
method, but the previous value for the scaling matrix <SPAN CLASS="MATH"><IMG
 WIDTH="54" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img88.gif"
 ALT="$H_{0,k-1}$"></SPAN> is used when 
computing <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img89.gif"
 ALT="$\sigma$"></SPAN>.  This is the rescaling method suggested in 
[].
</DD>
</DL>

<P>
Finally, a limit can be placed on the difference between the scaling
matrix computed at this iteration and the previous value for the
scaling matrix.  The limiting type can be set with the command line 
argument <TT>-tao_lmm_limit_type &lt;none,average,relative,absolute&gt;</TT>;
<TT>none</TT> is the default value.  Each of these methods is described 
below when using the <TT>scalar</TT> scaling method.  The techniques are
the same when using the <TT>broyden</TT> scaling method, but are applied
to each entry in the diagonal matrix.

<P>
<DL>
<DT><STRONG><TT>none</TT></STRONG></DT>
<DD>Set <!-- MATH
 $\sigma_k = \sigma$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="56" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img90.gif"
 ALT="$\sigma_k = \sigma$"></SPAN>, where <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img91.gif"
 ALT="$\sigma$"></SPAN> is the value
computed by the scaling method.
</DD>
<DT><STRONG><TT>average</TT></STRONG></DT>
<DD>Set <!-- MATH
 $\sigma_k = \mu \sigma + (1 - \mu) \sigma_{k-1}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="177" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img92.gif"
 ALT="$\sigma_k = \mu \sigma + (1 - \mu) \sigma_{k-1}$"></SPAN>, 
where <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img93.gif"
 ALT="$\sigma$"></SPAN> is the value computed by the scaling method, <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img94.gif"
 ALT="$\sigma_{k-1}$"></SPAN> is
the previous value, and <SPAN CLASS="MATH"><IMG
 WIDTH="71" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img95.gif"
 ALT="$\mu \in [0,1]$"></SPAN> is given.
</DD>
<DT><STRONG><TT>relative</TT></STRONG></DT>
<DD>Set <!-- MATH
 $\sigma_k = \mbox{median}\left\{ (1 - \mu) \sigma_{k-1}, \sigma, (1+\mu) \sigma_{k-1}\right\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="325" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img96.gif"
 ALT="$\sigma_k = \mbox{median}\left\{ (1 - \mu) \sigma_{k-1}, \sigma, (1+\mu) \sigma_{k-1}\right\}$"></SPAN>, 
where <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img97.gif"
 ALT="$\sigma$"></SPAN> is the value computed by the scaling method, <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img98.gif"
 ALT="$\sigma_{k-1}$"></SPAN> is 
the previous value, and <SPAN CLASS="MATH"><IMG
 WIDTH="71" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img99.gif"
 ALT="$\mu \in [0,1]$"></SPAN> is given.
</DD>
<DT><STRONG><TT>absolute</TT></STRONG></DT>
<DD>Set <!-- MATH
 $\sigma_k = \mbox{median}\left\{\sigma_{k-1} - \nu, \sigma, \sigma_{k-1} + \nu\right\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="278" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img100.gif"
 ALT="$\sigma_k = \mbox{median}\left\{\sigma_{k-1} - \nu, \sigma, \sigma_{k-1} + \nu\right\}$"></SPAN>, 
where <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img101.gif"
 ALT="$\sigma$"></SPAN> is the value computed by the scaling method, <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img102.gif"
 ALT="$\sigma_{k-1}$"></SPAN> is 
the previous value, and <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img103.gif"
 ALT="$\nu$"></SPAN> is given.
</DD>
</DL>
The value for <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img104.gif"
 ALT="$\mu$"></SPAN> is set with the command line argument 
<TT>-tao_lmm_limit_mu &lt;double&gt;</TT>; <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img105.gif"
 ALT="$1$"></SPAN> is the default value.
The value for <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img106.gif"
 ALT="$\nu$"></SPAN> is set with the command line argument 
<TT>-tao_lmm_limit_nu &lt;double&gt;</TT>.  The default value is 100.  

<P>
The default values for the scaling are based on many tests using the
unconstrained problems from the MINPACK-2 test set.  These tests were
used to narrow the choices to a few sets of values.  These values were
then run on the unconstrained problems from the CUTEr test set to
obtain the default values supplied.

<P>
<BR><P></P>
<DIV ALIGN="CENTER">

<A NAME="1347"></A>
<TABLE CELLPADDING=3 BORDER="1">
<CAPTION><STRONG>Table 4.1:</STRONG>
Summary of <TT>lmvm</TT> options</CAPTION>
<TR><TD ALIGN="LEFT">Name</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>Value</TD>
<TD ALIGN="LEFT">Default</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Description</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_lmm_vectors</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>int</TD>
<TD ALIGN="LEFT">5</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Number of vectors for Hessian approximation</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_lmm_scale_type</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>none, scalar, broyden</TD>
<TD ALIGN="LEFT">broyden</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Type of scaling method to use</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_lmm_scalar_history</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>int</TD>
<TD ALIGN="LEFT">5</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Number of vectors to use when scaling</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_lmm_scalar_alpha</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">1</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Value of <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img107.gif"
 ALT="$\alpha$"></SPAN> for scalar scaling method</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_lmm_broyden_phi</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.125</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Value of <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img108.gif"
 ALT="$\alpha$"></SPAN> for scalar scaling method</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_lmm_rescale_type</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>none, scalar, gl</TD>
<TD ALIGN="LEFT">scalar</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Type of rescaling method to use</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_lmm_rescale_history</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>int</TD>
<TD ALIGN="LEFT">5</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Number of vectors to use when rescaling</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_lmm_rescale_alpha</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">1</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Value of <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img109.gif"
 ALT="$\alpha$"></SPAN> for rescaling method</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_lmm_rescale_beta</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.5</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Value of <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img110.gif"
 ALT="$\beta$"></SPAN> for rescaling method</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_lmm_limit_type</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>none, average, relative, absolute</TD>
<TD ALIGN="LEFT">none</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Type of limit to impose on scaling matrix</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_lmm_limit_mu</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">1</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Value of <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img111.gif"
 ALT="$\mu$"></SPAN> for limit type</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_lmm_limit_nu</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">100</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Value of <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img112.gif"
 ALT="$\nu$"></SPAN> for limit type</TD>
</TR>
</TABLE>
</DIV><BR>

<P>

<H2><A NAME="SECTION00413000000000000000"></A><A NAME="1358"></A><A NAME="1359"></A><BR>
Nonlinear Conjugate Gradient Method
</H2>

<P>
The nonlinear conjugate gradient method can be viewed as an extensions of the 
conjugate gradient method for solving symmetric, positive-definite linear 
systems of equations.  This algorithm requires only function and gradient 
evaluations as well as a line search.  The TAO implementation uses a 
Mor&#233;-Thuente line search to obtain the step length.  The nonlinear 
conjugate gradient method can be selected by using the TaoMethod 
<TT>tao_cg</TT>.  For the best efficiency, function and gradient evaluations 
should be performed simultaneously when using this algorithm.

<P>
Five variations are currently supported by the TAO implementation: the 
Fletcher-Reeves method, the Polak-Ribi&#233;re method, the Polak-Ribi&#233;re-Plus 
method[<A
 HREF="manual.html#NW99">25</A>], the Hestenes-Stiefel method, and the Dai-Yuan method.  
These conjugate gradient methods can be specified by using the command line 
argument <TT>tao_cg_type &lt;fr,pr,prp,hs,dy&gt;</TT>, respectively.  The default 
value is <TT>prp</TT>.  

<P>
The conjugate gradient method incorporates automatic restarts when successive 
gradients are not sufficiently orthogonal.  TAO measures the orthogonality by 
dividing the inner product of the gradient at the current point and the 
gradient at the previous point by the square of the Euclidean norm of 
the gradient at the current point.  When the absolute value of this 
ratio is greater than <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img113.gif"
 ALT="$\eta$"></SPAN>, the algorithm restarts using the gradient 
direction.  The parameter <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img114.gif"
 ALT="$\eta$"></SPAN> can be set using the command line argument 
<TT>-tao_cg_eta &lt;double&gt;</TT>; 0.1 is the default value.  

<P>

<H2><A NAME="SECTION00414000000000000000"></A><A NAME="1360"></A><A NAME="1361"></A><BR>
Newton Line-Search Method
</H2>

<P>
The Newton line-search method solves the symmetric system of equations
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
H_k d_k = -g_k
\end{displaymath}
 -->

<IMG
 WIDTH="92" HEIGHT="30" BORDER="0"
 SRC="img115.gif"
 ALT="\begin{displaymath}
H_k d_k = -g_k
\end{displaymath}">
</DIV><BR CLEAR="ALL">
<P></P>
to obtain a step <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img116.gif"
 ALT="$d_k$"></SPAN>, where <SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img117.gif"
 ALT="$H_k$"></SPAN> is the Hessian of the objective function
at <SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img118.gif"
 ALT="$x_k$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img119.gif"
 ALT="$g_k$"></SPAN> is the gradient of the objective function at <SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img120.gif"
 ALT="$x_k$"></SPAN>.
For problems where the Hessian matrix is indefinite, the perturbed system
of equations
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
(H_k + \rho_k I) d_k = -g_k
\end{displaymath}
 -->

<IMG
 WIDTH="151" HEIGHT="31" BORDER="0"
 SRC="img121.gif"
 ALT="\begin{displaymath}
(H_k + \rho_k I) d_k = -g_k
\end{displaymath}">
</DIV><BR CLEAR="ALL">
<P></P>
is solved to obtain the direction, where <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img122.gif"
 ALT="$\rho_k$"></SPAN> is a positive constant.
If the direction computed is not a descent direction, the (scaled) steepest 
descent direction is used instead.  Having obtained the direction, 
a Mor&#233;-Thuente line search is applied to obtain a step length, 
<SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img123.gif"
 ALT="$\tau_k$"></SPAN>, that approximately solves the one-dimensional optimization 
problem
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
\min_\tau f(x_k + \tau d_k).
\end{displaymath}
 -->

<IMG
 WIDTH="125" HEIGHT="39" BORDER="0"
 SRC="img124.gif"
 ALT="\begin{displaymath}
\min_\tau f(x_k + \tau d_k).
\end{displaymath}">
</DIV><BR CLEAR="ALL">
<P></P>
The Newton line-search method can be set using the TaoMethod <TT>tao_nls</TT>.
For the best efficiency, function and gradient evaluations should be 
performed simultaneously when using this algorithm.

<P>
The system of equations is approximately solved by applying the conjugate 
gradient method, Steihaug-Toint conjugate gradient method, generalized 
Lanczos method, or an alternative Krylov subspace method 
supplied by PETSc.  The method used to solve the systems of equations is 
specified with the command line argument 
<TT>-tao_nls_ksp_type &lt;cg,stcg,gltr,petsc&gt;</TT>; <TT>cg</TT> 
is the default.  When the type is set to <TT>petsc</TT>, the method set with 
the PETSc <TT>-ksp_type</TT> command line argument is used.  For example, to 
use GMRES as the linear system solver, one would use the the command line 
arguments <TT>-tao_nls_ksp_type petsc -ksp_type gmres</TT>.  Internally,
the PETSc implementations for the conjugate gradient methods and the 
generalized Lanczos method are used.  See the PETSc manual for further 
information on changing the behavior of the linear system solvers.  

<P>
A good preconditioner reduces the number of iterations required to
solve the linear system of equations.  For the conjugate gradient
methods and generalized Lanczos method, this preconditioner must be
symmetric and positive definite.  The available options are to use no
preconditioner, the absolute value of the diagonal of the Hessian
matrix, a limited-memory BFGS approximation to the Hessian matrix, or
one of the other preconditioners provided by the PETSc package.  These
preconditioners are specified by the command line argument 
<TT>-tao_nls_pc_type &lt;none,ahess,bfgs,petsc&gt;</TT>, respectively. The
default is the <TT>bfgs</TT> preconditioner.  When the preconditioner
type is set to <TT>petsc</TT>, the preconditioner set with the PETSc 
<TT>-pc_type</TT> command line argument is used.  For example, to use an
incomplete Cholesky factorization for the preconditioner, one would
use the command line arguments 
<TT>-tao_nls_pc_type petsc -pc_type icc</TT>.  See the PETSc manual 
for further information on changing the behavior of the preconditioners.

<P>
The choice of scaling matrix can have a significant impact on the quality 
of the Hessian approximation when using the <TT>bfgs</TT> preconditioner and
affect the number of iterations required by the linear system solver.
The choices for scaling matrices are the same as those discussed for 
the limited-memory, variable-metric algorithm.  For Newton methods,
however, the option exists to use a scaling matrix based on the true
Hessian matrix.  In particular, the implementation supports using the 
absolute value of the diagonal of the Hessian matrix or the absolute 
value of the diagonal of the perturbed Hessian matrix.  The scaling 
matrix to use with the <TT>bfgs</TT> preconditioner is set with the 
command line argument <TT>-tao_nls_bfgs_scale_type &lt;bfgs,ahess,phess&gt;</TT>; 
<TT>phess</TT> is the default.  The <TT>bfgs</TT> scaling matrix is derived from 
the BFGS options.  The <TT>ahess</TT> scaling matrix is the absolute value of 
the diagonal of the Hessian matrix.  The <TT>phess</TT> scaling matrix is
the absolute value of the diagonal of the perturbed Hessian matrix.

<P>
The perturbation <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img125.gif"
 ALT="$\rho_k$"></SPAN> is added when the direction returned by the
Krylov subspace method is either not a descent direction, the Krylov method
diverged due to an indefinite preconditioner or matrix, or a direction of 
negative curvature was found.  In the two latter cases, if the step returned
is a descent direction, it is used during the line search.  Otherwise, a
steepest descent direction is used during the line search.  The perturbation
is decreased as long as the Krylov subspace method reports success and 
increased if further problems are encountered.  There are three cases:
initializing, increasing, and decreasing the perturbation.  These cases
are described below.

<OL>
<LI>If <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img126.gif"
 ALT="$\rho_k$"></SPAN> is zero and a problem was detected with either the
direction on the Krylov subspace method, the perturbation is initialized to
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
\rho_{k+1} = \mbox{median}\left\{\mbox{imin}, \mbox{imfac} * \|g(x_k)\|, \mbox{imax}\right\},
\end{displaymath}
 -->

<IMG
 WIDTH="342" HEIGHT="31" BORDER="0"
 SRC="img127.gif"
 ALT="\begin{displaymath}
\rho_{k+1} = \mbox{median}\left\{\mbox{imin}, \mbox{imfac} * \Vert g(x_k)\Vert, \mbox{imax}\right\},
\end{displaymath}">
</DIV><BR CLEAR="ALL">
<P></P>
where <TT>imin</TT> is set with the command line argument 
<TT>-tao_nls_imin &lt;double&gt;</TT> with a default value of <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="21" ALIGN="BOTTOM" BORDER="0"
 SRC="img128.gif"
 ALT="$10^{-4}$"></SPAN>,
<TT>imfac</TT> by <TT>-tao_nls_imfac</TT> with a default value of 0.1, and 
<TT>imax</TT> by <TT>-tao_nls_imax</TT> with a default value of 100.  
When using the <TT>gltr</TT> method to solve the system of equations, an
estimate of the minimum eigenvalue <SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img129.gif"
 ALT="$\lambda_1$"></SPAN> of the Hessian matrix 
is available.  This value is use to initialize the perturbation to
<!-- MATH
 $\rho_{k+1} = \max\left\{\rho_{k+1}, -\lambda_1\right\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="188" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img130.gif"
 ALT="$\rho_{k+1} = \max\left\{\rho_{k+1}, -\lambda_1\right\}$"></SPAN>.
</LI>
<LI>If <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img131.gif"
 ALT="$\rho_k$"></SPAN> is nonzero and a problem was detected with either the 
direction or Krylov subspace method, the perturbation is increased to 
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
\rho_{k+1} = \min\left\{\mbox{pmax}, \max\left\{\mbox{pgfac} * \rho_k, \mbox{pmgfac} * \|g(x_k)\|\right\}\right\},
\end{displaymath}
 -->

<IMG
 WIDTH="427" HEIGHT="31" BORDER="0"
 SRC="img132.gif"
 ALT="\begin{displaymath}
\rho_{k+1} = \min\left\{\mbox{pmax}, \max\left\{\mbox{pgfac} * \rho_k, \mbox{pmgfac} * \Vert g(x_k)\Vert\right\}\right\},
\end{displaymath}">
</DIV><BR CLEAR="ALL">
<P></P>
where <TT>pgfac</TT> is set with the command line argument <TT>-tao_nls_pgfac</TT>
with a default value of 10, <TT>pmgfac</TT> by <TT>-tao_nls_pmgfac</TT> with a
default value of 0.1, and <TT>pmax</TT> by <TT>-tao_nls_pmax</TT> with a default
value of 100.
</LI>
<LI>If <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img133.gif"
 ALT="$\rho_k$"></SPAN> is nonzero and no problems were detected with either
the direction or Krylov subspace method, the perturbation is decreased to
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
\rho_{k+1} = \min\left\{\mbox{psfac} * \rho_k, \mbox{pmsfac} * \|g(x_k)\|\right\},
\end{displaymath}
 -->

<IMG
 WIDTH="321" HEIGHT="31" BORDER="0"
 SRC="img134.gif"
 ALT="\begin{displaymath}
\rho_{k+1} = \min\left\{\mbox{psfac} * \rho_k, \mbox{pmsfac} * \Vert g(x_k)\Vert\right\},
\end{displaymath}">
</DIV><BR CLEAR="ALL">
<P></P>
where <TT>psfac</TT> is set with the command line argument <TT>-tao_nls_psfac</TT>
with a default value of 0.4, and <TT>pmsfac</TT> by <TT>-tao_nls_pmsfac</TT> with
a default value of 0.1.  Moreover, if <!-- MATH
 $\rho_{k+1} < \mbox{pmin}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="100" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img135.gif"
 ALT="$\rho_{k+1} &lt; \mbox{pmin}$"></SPAN> then 
<!-- MATH
 $\rho_{k+1} = 0$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="70" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img136.gif"
 ALT="$\rho_{k+1} = 0$"></SPAN>, where <TT>pmin</TT> is set with the command line argument 
<TT>-tao_nls_pmin</TT> and has a default value of <SPAN CLASS="MATH"><IMG
 WIDTH="46" HEIGHT="21" ALIGN="BOTTOM" BORDER="0"
 SRC="img137.gif"
 ALT="$10^{-12}$"></SPAN>.
</LI>
</OL>

<P>
When using <TT>stcg</TT> or <TT>gltr</TT> to solve the linear systems of equation,
a trust-region radius need to be initialized and updated.  This trust-region
radius limits the size of the step computed.  The method for initializing
the trust-region radius is set with the command line argument 
<TT>-tao_nls_init_type &lt;constant,direction,interpolation&gt;</TT>;
<TT>interpolation</TT>, which chooses an initial value based on the 
interpolation scheme found in [<A
 HREF="manual.html#CGT">5</A>], is the default.  This
scheme performs a number of function and gradient evaluations to determine 
a radius such that the reduction predicted by the quadratic model along the 
gradient direction coincides with the actual reduction in the nonlinear 
function.  The iterate obtaining the best objective function value is 
used as the starting point for the main line-search algorithm.  The 
<TT>constant</TT> method initializes the trust-region radius by using 
the value specified with the <TT>-tao_trust0 &lt;double&gt;</TT> command line 
argument, where the default value is 100.  The <TT>direction</TT> technique 
solves the first quadratic optimization problem by using a standard 
conjugate gradient method and initializes the trust-region to 
<SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img138.gif"
 ALT="$\Vert s_0\Vert$"></SPAN>.

<P>
Finally, the method for updating the trust-region radius is set with the 
command line argument 
<TT>-tao_nls_update_type &lt;step,reduction,interpolation&gt;</TT>; <TT>step</TT> 
is the default.  The <TT>step</TT> method updates the trust-region 
radius based on the value of <SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img139.gif"
 ALT="$\tau_k$"></SPAN>.  In particular,
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
\Delta_{k+1} = \left\{\begin{array}{ll}
\omega_1 \mbox{min}(\Delta_k, \|d_k\|) & \mbox{if } \tau_k \in [0, \nu_1) \\
\omega_2 \mbox{min}(\Delta_k, \|d_k\|) & \mbox{if } \tau_k \in [\nu_1, \nu_2) \\
\omega_3 \Delta_k & \mbox{if } \tau_k \in [\nu_2, \nu_3) \\
\mbox{max}(\Delta_k, \omega_4 \|d_k\|) & \mbox{if } \tau_k \in [\nu_3, \nu_4) \\
\mbox{max}(\Delta_k, \omega_5 \|d_k\|) & \mbox{if } \tau_k \in [\nu_4, \infty)
\end{array}
\right.
\end{displaymath}
 -->

<IMG
 WIDTH="336" HEIGHT="115" BORDER="0"
 SRC="img140.gif"
 ALT="\begin{displaymath}
\Delta_{k+1} = \left\{\begin{array}{ll}
\omega_1 \mbox{min}(...
...rt) &amp; \mbox{if } \tau_k \in [\nu_4, \infty)
\end{array}\right.
\end{displaymath}">
</DIV><BR CLEAR="ALL">
<P></P>
where <!-- MATH
 $0 < \omega_1 < \omega_2 < \omega_3 = 1 < \omega_4 < \omega_5$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="253" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img141.gif"
 ALT="$0 &lt; \omega_1 &lt; \omega_2 &lt; \omega_3 = 1 &lt; \omega_4 &lt; \omega_5$"></SPAN> and
<!-- MATH
 $0 < \nu_1 < \nu_2 < \nu_3 < \nu_4$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="170" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img142.gif"
 ALT="$0 &lt; \nu_1 &lt; \nu_2 &lt; \nu_3 &lt; \nu_4$"></SPAN> are constants.  The <TT>reduction</TT> 
method computes the ratio of the actual reduction in the objective function 
to the reduction predicted by the quadratic model for the full step, 
<!-- MATH
 $\kappa_k = \frac{f(x_k) - f(x_k + d_k)}{q(x_k) - q(x_k + d_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="151" HEIGHT="46" ALIGN="MIDDLE" BORDER="0"
 SRC="img143.gif"
 ALT="$\kappa_k = \frac{f(x_k) - f(x_k + d_k)}{q(x_k) - q(x_k + d_k)}$"></SPAN>, where 
<SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img144.gif"
 ALT="$q_k$"></SPAN> is the quadratic model.  The radius is then updated as:
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
\Delta_{k+1} = \left\{\begin{array}{ll}
\alpha_1 \mbox{min}(\Delta_k, \|d_k\|) & \mbox{if } \kappa_k \in (-\infty, \eta_1) \\
\alpha_2 \mbox{min}(\Delta_k, \|d_k\|) & \mbox{if } \kappa_k \in [\eta_1, \eta_2) \\
\alpha_3 \Delta_k & \mbox{if } \kappa_k \in [\eta_2, \eta_3) \\
\mbox{max}(\Delta_k, \alpha_4 \|d_k\|) & \mbox{if } \kappa_k \in [\eta_3, \eta_4) \\
\mbox{max}(\Delta_k, \alpha_5 \|d_k\|) & \mbox{if } \kappa_k \in [\eta_4, \infty)
\end{array}
\right.
\end{displaymath}
 -->

<IMG
 WIDTH="354" HEIGHT="115" BORDER="0"
 SRC="img145.gif"
 ALT="\begin{displaymath}
\Delta_{k+1} = \left\{\begin{array}{ll}
\alpha_1 \mbox{min}(...
... &amp; \mbox{if } \kappa_k \in [\eta_4, \infty)
\end{array}\right.
\end{displaymath}">
</DIV><BR CLEAR="ALL">
<P></P>
where <!-- MATH
 $0 < \alpha_1 < \alpha_2 < \alpha_3 = 1 < \alpha_4 < \alpha_5$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="254" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img146.gif"
 ALT="$0 &lt; \alpha_1 &lt; \alpha_2 &lt; \alpha_3 = 1 &lt; \alpha_4 &lt; \alpha_5$"></SPAN> and
<!-- MATH
 $0 < \eta_1 < \eta_2 < \eta_3 < \eta_4$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="170" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img147.gif"
 ALT="$0 &lt; \eta_1 &lt; \eta_2 &lt; \eta_3 &lt; \eta_4$"></SPAN> are constants.  The <TT>interpolation</TT>
method uses the same interpolation mechanism as in the initialization to
compute a new value for the trust-region radius.

<P>
<BR><P></P>
<DIV ALIGN="CENTER">

<A NAME="1349"></A>
<TABLE CELLPADDING=3 BORDER="1">
<CAPTION><STRONG>Table 4.2:</STRONG>
Summary of <TT>nls</TT> options</CAPTION>
<TR><TD ALIGN="LEFT">Name</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>Value</TD>
<TD ALIGN="LEFT">Default</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Description</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_ksp_type</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>cg, stcg, gltr, petsc</TD>
<TD ALIGN="LEFT">cg</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Type of Krylov subspace method to use when solving linear system</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_pc_type</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>none, ahess, bfgs, petsc</TD>
<TD ALIGN="LEFT">bfgs</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Type of preconditioner to use when solving linear system</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_bfgs_scale_type</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>ahess, phess, bfgs</TD>
<TD ALIGN="LEFT">phess</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Type of scaling matrix to use with BFGS preconditioner</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_sval</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img148.gif"
 ALT="$0$"></SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Initial perturbation value</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_imin</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="21" ALIGN="BOTTOM" BORDER="0"
 SRC="img149.gif"
 ALT="$10^{-4}$"></SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Minimum initial perturbation value</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_imax</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="30" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img150.gif"
 ALT="$100$"></SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Maximum initial perturbation value</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_imfac</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="26" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img151.gif"
 ALT="$0.1$"></SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Factor applied to norm of gradient when initializing perturbation</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_pmax</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="30" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img152.gif"
 ALT="$100$"></SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Maximum perturbation when increasing value</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_pgfac</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img153.gif"
 ALT="$10$"></SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Growth factor applied to perturbation when increasing value</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_pmgfac</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="26" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img154.gif"
 ALT="$0.1$"></SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Factor applied to norm of gradient when increasing perturbation</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_pmin</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="46" HEIGHT="21" ALIGN="BOTTOM" BORDER="0"
 SRC="img155.gif"
 ALT="$10^{-12}$"></SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Minimum perturbation when decreasing value; smaller values set to zero</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_psfac</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="26" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img156.gif"
 ALT="$0.4$"></SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Shrink factor applied to perturbation when decreasing value</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_pmsfac</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="26" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img157.gif"
 ALT="$0.1$"></SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Factor applied to norm of gradient when decreasing perturbation</TD>
</TR>
</TABLE>
</DIV><BR>

<P>
<BR><P></P>
<DIV ALIGN="CENTER">

<A NAME="1351"></A>
<TABLE CELLPADDING=3 BORDER="1">
<CAPTION><STRONG>Table 4.3:</STRONG>
Summary of <TT>nls</TT> options (continued)</CAPTION>
<TR><TD ALIGN="LEFT">Name</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>Value</TD>
<TD ALIGN="LEFT">Default</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Description</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_init_type</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>constant, direction, interpolation</TD>
<TD ALIGN="LEFT">interpolation</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Method used to initialize trust-region radius when using <TT>stcg</TT> or <TT>gltr</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_mu1_i</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.35</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img158.gif"
 ALT="$\mu_1$"></SPAN> in <TT>interpolation</TT> init</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_mu2_i</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.50</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img159.gif"
 ALT="$\mu_2$"></SPAN> in <TT>interpolation</TT> init</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_gamma1_i</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.0625</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img160.gif"
 ALT="$\gamma_1$"></SPAN> in <TT>interpolation</TT> init</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_gamma2_i</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.50</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img161.gif"
 ALT="$\gamma_2$"></SPAN> in <TT>interpolation</TT> init</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_gamma3_i</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">2.00</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img162.gif"
 ALT="$\gamma_3$"></SPAN> in <TT>interpolation</TT> init</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_gamma4_i</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">5.00</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img163.gif"
 ALT="$\gamma_4$"></SPAN> in <TT>interpolation</TT> init</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_theta_i</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.25</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img164.gif"
 ALT="$\theta$"></SPAN> in <TT>interpolation</TT> init</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_update_type</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>step, reduction, interpolation</TD>
<TD ALIGN="LEFT">step</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Method used to update trust-region radius when using <TT>stcg</TT> or <TT>gltr</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_nu1</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.25</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img165.gif"
 ALT="$\nu_1$"></SPAN> in <TT>step</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_nu2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.50</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img166.gif"
 ALT="$\nu_2$"></SPAN> in <TT>step</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_nu3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">1.00</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img167.gif"
 ALT="$\nu_3$"></SPAN> in <TT>step</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_nu4</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">1.25</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img168.gif"
 ALT="$\nu_4$"></SPAN> in <TT>step</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_omega1</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.25</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img169.gif"
 ALT="$\omega_1$"></SPAN> in <TT>step</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_omega2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.50</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img170.gif"
 ALT="$\omega_2$"></SPAN> in <TT>step</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_omega3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">1.00</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img171.gif"
 ALT="$\omega_3$"></SPAN> in <TT>step</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_omega4</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">2.00</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img172.gif"
 ALT="$\omega_4$"></SPAN> in <TT>step</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_omega5</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">4.00</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img173.gif"
 ALT="$\omega_5$"></SPAN> in <TT>step</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_eta1</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="21" ALIGN="BOTTOM" BORDER="0"
 SRC="img174.gif"
 ALT="$10^{-4}$"></SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img175.gif"
 ALT="$\eta_1$"></SPAN> in <TT>reduction</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_eta2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.25</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img176.gif"
 ALT="$\eta_2$"></SPAN> in <TT>reduction</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_eta3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.50</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img177.gif"
 ALT="$\eta_3$"></SPAN> in <TT>reduction</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_eta4</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.90</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img178.gif"
 ALT="$\eta_4$"></SPAN> in <TT>reduction</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_alpha1</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.25</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="23" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img179.gif"
 ALT="$\alpha_1$"></SPAN> in <TT>reduction</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_alpha2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.50</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="23" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img180.gif"
 ALT="$\alpha_2$"></SPAN> in <TT>reduction</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_alpha3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">1.00</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="23" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img181.gif"
 ALT="$\alpha_3$"></SPAN> in <TT>reduction</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_alpha4</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">2.00</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="23" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img182.gif"
 ALT="$\alpha_4$"></SPAN> in <TT>reduction</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_alpha5</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">4.00</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="23" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img183.gif"
 ALT="$\alpha_5$"></SPAN> in <TT>reduction</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_mu1</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.10</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img184.gif"
 ALT="$\mu_1$"></SPAN> in <TT>interpolation</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_mu2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.50</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img185.gif"
 ALT="$\mu_2$"></SPAN> in <TT>interpolation</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_gamma1</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.25</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img186.gif"
 ALT="$\gamma_1$"></SPAN> in <TT>interpolation</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_gamma2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.50</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img187.gif"
 ALT="$\gamma_2$"></SPAN> in <TT>interpolation</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_gamma3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">2.00</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img188.gif"
 ALT="$\gamma_3$"></SPAN> in <TT>interpolation</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_gamma4</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">4.00</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img189.gif"
 ALT="$\gamma_4$"></SPAN> in <TT>interpolation</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_nls_theta</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.05</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img190.gif"
 ALT="$\theta$"></SPAN> in <TT>interpolation</TT> update</TD>
</TR>
</TABLE>
</DIV><BR>

<P>

<H2><A NAME="SECTION00415000000000000000"></A><A NAME="1362"></A><A NAME="1363"></A><BR>
Newton Trust-Region Method
</H2>

<P>
The Newton trust-region method solves the constrained quadratic programming
problem
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
\begin{array}{ll}
\min_d  & \frac{1}{2}d^T H_k d  + g_k^T d \\
\mbox{subject to} & \|d\| \leq \Delta_k
\end{array}
\end{displaymath}
 -->

<IMG
 WIDTH="204" HEIGHT="50" BORDER="0"
 SRC="img191.gif"
 ALT="\begin{displaymath}
\begin{array}{ll}
\min_d &amp; \frac{1}{2}d^T H_k d + g_k^T d \\
\mbox{subject to} &amp; \Vert d\Vert \leq \Delta_k
\end{array}\end{displaymath}">
</DIV><BR CLEAR="ALL">
<P></P>
to obtain a direction <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img192.gif"
 ALT="$d_k$"></SPAN>, where <SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img193.gif"
 ALT="$H_k$"></SPAN> is the Hessian of the objective 
function at <SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img194.gif"
 ALT="$x_k$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img195.gif"
 ALT="$g_k$"></SPAN> is the gradient of the objective function at <SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img196.gif"
 ALT="$x_k$"></SPAN> 
and <SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img197.gif"
 ALT="$\Delta_k$"></SPAN> is the trust-region radius.  If <SPAN CLASS="MATH"><IMG
 WIDTH="61" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img198.gif"
 ALT="$x_k + d_k$"></SPAN> sufficiently 
reduces the nonlinear objective function, then the step is accepted and the 
trust-region radius is updated.  However, if <SPAN CLASS="MATH"><IMG
 WIDTH="61" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img199.gif"
 ALT="$x_k + d_k$"></SPAN> does not sufficiently
reduce the nonlinear objective function, then the step is rejected, the 
trust-region radius is reduced, and the quadratic program is re-solved 
using the updated trust-region radius. The Newton trust-region method 
can be set using TaoMethod <TT>tao_ntr</TT>.  For the best efficiency, 
function and gradient evaluations should be performed separately when 
using this algorithm.

<P>
The quadratic optimization problem is approximately solved by applying
the Steihaug-Toint conjugate gradient method or generalized Lanczos 
method to the symmetric system of equations <SPAN CLASS="MATH"><IMG
 WIDTH="89" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img200.gif"
 ALT="$H_k d = -g_k$"></SPAN>.  The method 
used to solve the system of equations is specified with the command line
argument <TT>-tao_ntr_ksp_type &lt;stcg,gltr&gt;</TT>; <TT>stcg</TT> is the default.  
Internally, the PETSc implementations for the Steihaug-Toint method and the 
generalized Lanczos method are used.  See the PETSc manual for further 
information on changing the behavior of these linear system solvers.  

<P>
A good preconditioner reduces the number of iterations required to
compute the direction.  For the Steihaug-Toint conjugate gradient
method and generalized Lanczos method, this preconditioner must be
symmetric and positive definite.  The available options are to use no
preconditioner, the absolute value of the diagonal of the Hessian
matrix, a limited-memory BFGS approximation to the Hessian matrix, or
one of the other preconditioners provided by the PETSc package.  These
preconditioners are specified by the the command line argument 
<TT>-tao_ntr_pc_type &lt;none,ahess,bfgs,petsc&gt;</TT>, respectively.  The
default is the <TT>bfgs</TT> preconditioner.  When the preconditioner
type is set the to <TT>petsc</TT>, the preconditioner set with the PETSc
<TT>-pc_type</TT> command line argument is used.  For example, to use an
incomplete Cholesky factorization for the preconditioner, one would
use the command line arguments 
<TT>-tao_ntr_pc_type petsc -pc_type icc</TT>.  See the PETSc manual 
for further information on changing the behavior of the preconditioners.

<P>
The choice of scaling matrix can have a significant impact on the quality 
of the Hessian approximation when using the <TT>bfgs</TT> preconditioner and
affect the number of iterations required by the linear system solver.
The choices for scaling matrices are the same as those discussed for 
the limited-memory, variable-metric algorithm.  For Newton methods,
however, the option exists to use a scaling matrix based on the true
Hessian matrix.  In particular, the implementation supports using the 
absolute value of the diagonal of the Hessian matrix.  The scaling 
matrix to use with the <TT>bfgs</TT> preconditioner is set with the 
command line argument <TT>-tao_ntr_bfgs_scale_type &lt;ahess,bfgs&gt;</TT>; 
<TT>ahess</TT> is the default.  The <TT>bfgs</TT> scaling matrix is derived from 
the BFGS options.  The <TT>ahess</TT> scaling matrix is the absolute value of 
the diagonal of the Hessian matrix.

<P>
The method for computing an initial trust-region radius is set with the 
command line argument <TT>-tao_ntr_init_type &lt;constant,direction,interpolation&gt;</TT>;
<TT>interpolation</TT>, which chooses an initial value based on the 
interpolation scheme found in [<A
 HREF="manual.html#CGT">5</A>], is the default.  This
scheme performs a number of function and gradient evaluations to determine 
a radius such that the reduction predicted by the quadratic model along the 
gradient direction coincides with the actual reduction in the nonlinear 
function.  The iterate obtaining the best objective function value is 
used as the starting point for the main line-search algorithm.  The 
<TT>constant</TT> method initializes the trust-region radius by using 
the value specified with the <TT>-tao_trust0 &lt;double&gt;</TT> command line 
argument, where the default value is 100.  The <TT>direction</TT> technique 
solves the first quadratic optimization problem by using a standard 
conjugate gradient method and initializes the trust-region to 
<SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img201.gif"
 ALT="$\Vert s_0\Vert$"></SPAN>.

<P>
Finally, the method for updating the trust-region radius is set with the 
command line argument 
<TT>-tao_ntr_update_type &lt;reduction,interpolation&gt;</TT>; <TT>reduction</TT> 
is the default.  The <TT>reduction</TT> method computes the ratio of the 
actual reduction in the objective function to the reduction predicted 
by the quadratic model for the full step, 
<!-- MATH
 $\kappa_k = \frac{f(x_k) - f(x_k + d_k)}{q(x_k) - q(x_k + d_k)}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="151" HEIGHT="46" ALIGN="MIDDLE" BORDER="0"
 SRC="img202.gif"
 ALT="$\kappa_k = \frac{f(x_k) - f(x_k + d_k)}{q(x_k) - q(x_k + d_k)}$"></SPAN>, where 
<SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img203.gif"
 ALT="$q_k$"></SPAN> is the quadratic model.  The radius is then updated as:
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
\Delta_{k+1} = \left\{\begin{array}{ll}
\alpha_1 \mbox{min}(\Delta_k, \|d_k\|) & \mbox{if } \kappa_k \in (-\infty, \eta_1) \\
\alpha_2 \mbox{min}(\Delta_k, \|d_k\|) & \mbox{if } \kappa_k \in [\eta_1, \eta_2) \\
\alpha_3 \Delta_k & \mbox{if } \kappa_k \in [\eta_2, \eta_3) \\
\mbox{max}(\Delta_k, \alpha_4 \|d_k\|) & \mbox{if } \kappa_k \in [\eta_3, \eta_4) \\
\mbox{max}(\Delta_k, \alpha_5 \|d_k\|) & \mbox{if } \kappa_k \in [\eta_4, \infty)
\end{array}
\right.
\end{displaymath}
 -->

<IMG
 WIDTH="354" HEIGHT="115" BORDER="0"
 SRC="img204.gif"
 ALT="\begin{displaymath}
\Delta_{k+1} = \left\{\begin{array}{ll}
\alpha_1 \mbox{min}(...
... &amp; \mbox{if } \kappa_k \in [\eta_4, \infty)
\end{array}\right.
\end{displaymath}">
</DIV><BR CLEAR="ALL">
<P></P>
where <!-- MATH
 $0 < \alpha_1 < \alpha_2 < \alpha_3 = 1 < \alpha_4 < \alpha_5$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="254" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img205.gif"
 ALT="$0 &lt; \alpha_1 &lt; \alpha_2 &lt; \alpha_3 = 1 &lt; \alpha_4 &lt; \alpha_5$"></SPAN> and
<!-- MATH
 $0 < \eta_1 < \eta_2 < \eta_3 < \eta_4$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="170" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img206.gif"
 ALT="$0 &lt; \eta_1 &lt; \eta_2 &lt; \eta_3 &lt; \eta_4$"></SPAN> are constants.  The <TT>interpolation</TT>
method uses the same interpolation mechanism as in the initialization to
compute a new value for the trust-region radius.

<P>
<BR><P></P>
<DIV ALIGN="CENTER">

<A NAME="1353"></A>
<TABLE CELLPADDING=3 BORDER="1">
<CAPTION><STRONG>Table 4.4:</STRONG>
Summary of <TT>ntr</TT> options</CAPTION>
<TR><TD ALIGN="LEFT">Name</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>Value</TD>
<TD ALIGN="LEFT">Default</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Description</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_ksp_type</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>stcg, gltr</TD>
<TD ALIGN="LEFT">stcg</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Type of Krylov subspace method to use when solving linear system</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_pc_type</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>none, ahess, bfgs, petsc</TD>
<TD ALIGN="LEFT">bfgs</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Type of preconditioner to use when solving linear system</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_bfgs_scale_type</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>ahess, bfgs</TD>
<TD ALIGN="LEFT">ahess</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Type of scaling matrix to use with BFGS preconditioner</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_init_type</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>constant, direction, interpolation</TD>
<TD ALIGN="LEFT">interpolation</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Method used to initialize trust-region radius</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_mu1_i</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.35</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img207.gif"
 ALT="$\mu_1$"></SPAN> in <TT>interpolation</TT> init</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_mu2_i</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.50</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img208.gif"
 ALT="$\mu_2$"></SPAN> in <TT>interpolation</TT> init</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_gamma1_i</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.0625</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img209.gif"
 ALT="$\gamma_1$"></SPAN> in <TT>interpolation</TT> init</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_gamma2_i</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.50</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img210.gif"
 ALT="$\gamma_2$"></SPAN> in <TT>interpolation</TT> init</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_gamma3_i</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">2.00</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img211.gif"
 ALT="$\gamma_3$"></SPAN> in <TT>interpolation</TT> init</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_gamma4_i</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">5.00</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img212.gif"
 ALT="$\gamma_4$"></SPAN> in <TT>interpolation</TT> init</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_theta_i</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.25</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img213.gif"
 ALT="$\theta$"></SPAN> in <TT>interpolation</TT> init</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_update_type</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>reduction, interpolation</TD>
<TD ALIGN="LEFT">reduction</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144>Method used to update trust-region radius</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_eta1</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="21" ALIGN="BOTTOM" BORDER="0"
 SRC="img214.gif"
 ALT="$10^{-4}$"></SPAN></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img215.gif"
 ALT="$\eta_1$"></SPAN> in <TT>reduction</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_eta2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.25</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img216.gif"
 ALT="$\eta_2$"></SPAN> in <TT>reduction</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_eta3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.50</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img217.gif"
 ALT="$\eta_3$"></SPAN> in <TT>reduction</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_eta4</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.90</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img218.gif"
 ALT="$\eta_4$"></SPAN> in <TT>reduction</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_alpha1</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.25</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="23" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img219.gif"
 ALT="$\alpha_1$"></SPAN> in <TT>reduction</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_alpha2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.50</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="23" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img220.gif"
 ALT="$\alpha_2$"></SPAN> in <TT>reduction</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_alpha3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">1.00</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="23" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img221.gif"
 ALT="$\alpha_3$"></SPAN> in <TT>reduction</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_alpha4</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">2.00</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="23" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img222.gif"
 ALT="$\alpha_4$"></SPAN> in <TT>reduction</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_alpha5</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">4.00</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="23" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img223.gif"
 ALT="$\alpha_5$"></SPAN> in <TT>reduction</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_mu1</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.10</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img224.gif"
 ALT="$\mu_1$"></SPAN> in <TT>interpolation</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_mu2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.50</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img225.gif"
 ALT="$\mu_2$"></SPAN> in <TT>interpolation</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_gamma1</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.25</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img226.gif"
 ALT="$\gamma_1$"></SPAN> in <TT>interpolation</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_gamma2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.50</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img227.gif"
 ALT="$\gamma_2$"></SPAN> in <TT>interpolation</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_gamma3</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">2.00</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img228.gif"
 ALT="$\gamma_3$"></SPAN> in <TT>interpolation</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_gamma4</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">4.00</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img229.gif"
 ALT="$\gamma_4$"></SPAN> in <TT>interpolation</TT> update</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>-tao_ntr_theta</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=108>double</TD>
<TD ALIGN="LEFT">0.05</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=144><SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img230.gif"
 ALT="$\theta$"></SPAN> in <TT>interpolation</TT> update</TD>
</TR>
</TABLE>
</DIV><BR>

<P>

<H1><A NAME="SECTION00420000000000000000"></A><A NAME="1364"></A>
<A NAME="chapter:bound"></A><BR>
Bound Constrained Optimization
</H1>

<P>
Bound constrained optimization algorithms
minimize <!-- MATH
 $f: \, \mathbb{R}^n \to \mathbb{R}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="93" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img231.gif"
 ALT="$f: \, \mathbb{R}^n \to \mathbb{R}$"></SPAN>, subject to upper or
lower bounds on some of the variables.
These solvers also bounds on the variables as well as objective
function, gradient, and possibly Hessian information.

<P>

<H2><A NAME="SECTION00421000000000000000"></A><A NAME="sec:tron"></A> <A NAME="1365"></A> <A NAME="1366"></A><BR>
Newton Trust Region
</H2>
The TRON [<A
 HREF="manual.html#lin_c3">18</A>] algorithm is an active set method that uses a 
combination of gradient projections and 
a preconditioned conjugate gradient method to minimize an objective function.
Each iteration of the TRON algorithm requires function, gradient, 
and Hessian evaluations.  In each iteration, the algorithm
first applies several conjugate
gradients.  
After these iterates, the TRON solver momentarily ignores the variables
that equal one of its bounds and
applies a preconditioned conjugate gradient method to a
quadratic model of the free variables.  

<P>
The TRON algorithm solves a reduced linear system
defined by the rows and columns corresponding to the variables that
lie between the upper and lower bounds.
When running in parallel, these rows can either remain on
their current processor or be redistributed evenly over all of the
processors with the command <TT>TaoSelectSubset()</TT>.
The TRON algorithm applies a trust region to the 
conjugate gradients to ensure convergence.  The initial trust region
can be set using the command 
<TT>TaoSetTrustRegionRadius()</TT>
and the current trust region size can be found using the command
<TT>TaoGetTrustRegionRadius().</TT>
The initial trust region can significantly alter the 
rate of convergence for the algorithm and should be
tuned and adjusted for optimal performance.

<P>

<H2><A NAME="SECTION00422000000000000000">
Gradient Projection-Conjugate Gradient Method</A>
</H2>
The GPCG [<A
 HREF="manual.html#more-toraldo">20</A>] algorithm is much like the TRON algorithm, discussed in
Section <A HREF="#sec:tron">4.2.1</A>, except that
it assumes that the objective function is quadratic and convex.
Therefore, it evaluates the function, gradient, and Hessian only
once.
Since the objective function
is quadratic, the algorithm does not use a trust region.  
All of the options that apply to TRON, except for trust region
options,  also apply to GPCG.

<P>

<H2><A NAME="SECTION00423000000000000000">
Interior Point Newton Algorithm</A>
</H2>
The BQPIP algorithm is an interior point algorithm for bound
constrained quadratic optimization.  It can be set using the
TaoMethod of <TT>tao_bqpip</TT>.
Since it assumes the objective function is quadratic, 
it evaluates the function, gradient, and Hessian only once.
In this algorithm all of the variables are free variables.
This method also requires the solution of systems of linear equations,
whose solver can be accessed and modified 
with the command <TT>TaoGetLinearSolver()</TT>.

<P>

<H2><A NAME="SECTION00424000000000000000">
Limited Memory Variable Metric Method</A>
</H2>

<P>
This method is the bound constrained variant of the LMVM method for
unconstrained optimization.  It uses projected gradients to approximate
the Hessian - eliminating the need for Hessian evaluations.
The method can be set using  TaoMethod <TT>tao_blmvm</TT>.
The command <TT>TaoLMVMSetSize()</TT>, which sets the number
of vectors to be used in the Hessian approximation, 
also applies to this method.

<P>

<H2><A NAME="SECTION00425000000000000000"></A> <A NAME="1367"></A><BR>
KT Method
</H2>

<P>
This method calculates points satisfying the first-order necessary 
optimality conditions.  The method uses the mixed complementarity
problem solvers from Section <A HREF="#sec:complementarity">4.3</A> to calculate
the solutions.  The choice of complementarity solver is specified
with the runtime option <TT>-tao_kt_method</TT> with the default
being the <TT>tao_ssils</TT> method.

<P>

<H1><A NAME="SECTION00430000000000000000"></A>
<A NAME="sec:complementarity"></A><BR>
Complementarity
</H1>

<P>
Mixed complementarity problems, or box-constrained variational inequalities,
are related to nonlinear systems of equations.  They are defined by a 
continuously differentiable function,
<!-- MATH
 $F:\mathbb{R}^n \to \mathbb{R}^n$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="102" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img232.gif"
 ALT="$F:\mathbb{R}^n \to \mathbb{R}^n$"></SPAN>, and bounds, <!-- MATH
 $\ell \in \{\mathbb{R}\cup \{-\infty\}\}^n$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="139" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img233.gif"
 ALT="$\ell \in \{\mathbb{R}\cup \{-\infty\}\}^n$"></SPAN> 
and <!-- MATH
 $u \in \{\mathbb{R}\cup \{\infty\}\}^n$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="128" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img234.gif"
 ALT="$u \in \{\mathbb{R}\cup \{\infty\}\}^n$"></SPAN>, on the variables such that 
<SPAN CLASS="MATH"><IMG
 WIDTH="44" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img235.gif"
 ALT="$\ell \leq u$"></SPAN>.  Given this information, <!-- MATH
 $\mbox{\boldmath\(x\)}^* \in [\ell,u]$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="79" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img236.gif"
 ALT="$\mbox{\boldmath\(x\)}^* \in [\ell,u]$"></SPAN> is a solution to 
MCP(<SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img237.gif"
 ALT="$F$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img238.gif"
 ALT="$\ell$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img239.gif"
 ALT="$u$"></SPAN>) if for each <!-- MATH
 $i \in \{1, \ldots, n\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="107" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img240.gif"
 ALT="$i \in \{1, \ldots, n\}$"></SPAN> we have at
least one of the following:
<P></P><DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{eqnarray*}
\begin{array}{ll}
F_i(x^*) \geq 0 & \mbox{if } x^*_i = \ell_i \\
F_i(x^*) = 0 & \mbox{if } \ell_i < x^*_i < u_i \\
F_i(x^*) \leq 0 & \mbox{if } x^*_i = u_i.
\end{array}
\end{eqnarray*}
 -->
<IMG
 WIDTH="202" HEIGHT="72" BORDER="0"
 SRC="img241.gif"
 ALT="\begin{eqnarray*}
\begin{array}{ll}
F_i(x^*) \geq 0 &amp; \mbox{if } x^*_i = \ell_i ...
...i &lt; u_i \\
F_i(x^*) \leq 0 &amp; \mbox{if } x^*_i = u_i.
\end{array}\end{eqnarray*}"></DIV><BR CLEAR="ALL"><P></P>
<BR CLEAR="ALL"><P></P>
Note that when <!-- MATH
 $\ell = \{-\infty\}^n$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="92" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img242.gif"
 ALT="$\ell = \{-\infty\}^n$"></SPAN> and <!-- MATH
 $u = \{\infty\}^n$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="81" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img243.gif"
 ALT="$u = \{\infty\}^n$"></SPAN> we have a 
nonlinear system of equations, and <!-- MATH
 $\ell = \{0\}^n$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="70" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img244.gif"
 ALT="$\ell = \{0\}^n$"></SPAN> and <!-- MATH
 $u = \{\infty\}^n$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="81" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img245.gif"
 ALT="$u = \{\infty\}^n$"></SPAN> 
corresponds to the nonlinear complementarity problem [<A
 HREF="manual.html#cottle:nonlinear">6</A>].

<P>
Simple complementarity conditions arise from the first-order optimality 
conditions from optimization [<A
 HREF="manual.html#karush:minima">16</A>,<A
 HREF="manual.html#kuhn.tucker:nonlinear">17</A>].  
In the simple bound constrained optimization case, these conditions 
correspond to MCP(<SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img246.gif"
 ALT="$\nabla f$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img247.gif"
 ALT="$\ell$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img248.gif"
 ALT="$u$"></SPAN>), where <!-- MATH
 $f: \mathbb{R}^n \to \mathbb{R}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="90" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img249.gif"
 ALT="$f: \mathbb{R}^n \to \mathbb{R}$"></SPAN> 
is the objective function.  In a one-dimensional setting these conditions 
are intuitive.  If the solution is at the lower bound, then the function must 
be increasing and <!-- MATH
 $\nabla f \geq 0$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="61" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img250.gif"
 ALT="$\nabla f \geq 0$"></SPAN>.  However, if the solution is at the 
upper bound, then the function must be decreasing and <!-- MATH
 $\nabla f \leq 0$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="61" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img251.gif"
 ALT="$\nabla f \leq 0$"></SPAN>.  
Finally, if the solution 
is strictly between the bounds, we must be at a stationary point and 
<SPAN CLASS="MATH"><IMG
 WIDTH="61" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img252.gif"
 ALT="$\nabla f = 0$"></SPAN>.  Other complementarity problems arise in economics and 
engineering [<A
 HREF="manual.html#ferris.pang:engineering">9</A>], game 
theory [<A
 HREF="manual.html#nash:equilibrium">23</A>], and finance [<A
 HREF="manual.html#huang.pang:option">14</A>].

<P>
Evaluation routines for <SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img253.gif"
 ALT="$F$"></SPAN> and its Jacobian must be supplied prior
to solving the application.
The bounds, <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img254.gif"
 ALT="$[\ell,u]$"></SPAN>, on the variables must also be 
provided.  
If no starting point is supplied, a default starting point of all zeros 
is used.

<P>

<H2><A NAME="SECTION00431000000000000000">
Semismooth Methods</A>
</H2>

<P>
TAO has two implementations of semismooth algorithms 
[<A
 HREF="manual.html#munson.facchinei.ea:semismooth">22</A>,<A
 HREF="manual.html#deluca.facchinei.ea:semismooth">7</A>,<A
 HREF="manual.html#facchinei.fischer.ea:semismooth">8</A>] for solving mixed complementarity problems.
Both are based upon a reformulation of the mixed complementarity problem
as a nonsmooth system of equations using the Fischer-Burmeister 
function [<A
 HREF="manual.html#fischer:special">10</A>].  A nonsmooth Newton method is applied to
the reformulated system to calculate a solution.  The theoretical properties
of such methods are detailed in the aforementioned references.

<P>
The Fischer-Burmeister function, <!-- MATH
 $\phi:\mathbb{R}^2 \to \mathbb{R}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="89" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="img255.gif"
 ALT="$\phi:\mathbb{R}^2 \to \mathbb{R}$"></SPAN>, is defined as,
<P></P><DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{eqnarray*}
\phi(a,b) := \sqrt{a^2 + b^2} - a - b.
\end{eqnarray*}
 -->
<IMG
 WIDTH="209" HEIGHT="31" BORDER="0"
 SRC="img256.gif"
 ALT="\begin{eqnarray*}
\phi(a,b) := \sqrt{a^2 + b^2} - a - b.
\end{eqnarray*}"></DIV><BR CLEAR="ALL"><P></P>
<BR CLEAR="ALL"><P></P>
This function has the following key property
<P></P><DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{eqnarray*}
\begin{array}{lcr}
        \phi(a,b) = 0 & \Leftrightarrow & a \geq 0,\; b \geq 0,\; ab = 0
\end{array}
\end{eqnarray*}
 -->
<IMG
 WIDTH="283" HEIGHT="33" BORDER="0"
 SRC="img257.gif"
 ALT="\begin{eqnarray*}
\begin{array}{lcr}
\phi(a,b) = 0 &amp; \Leftrightarrow &amp; a \geq 0,\; b \geq 0,\; ab = 0
\end{array}\end{eqnarray*}"></DIV><BR CLEAR="ALL"><P></P>
<BR CLEAR="ALL"><P></P>
used when reformulating the mixed complementarity problem the system of 
equations <SPAN CLASS="MATH"><IMG
 WIDTH="72" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img258.gif"
 ALT="$\Phi(x) = 0$"></SPAN> where <!-- MATH
 $\Phi:\mathbb{R}^n \to \mathbb{R}^n$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="101" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img259.gif"
 ALT="$\Phi:\mathbb{R}^n \to \mathbb{R}^n$"></SPAN>.  
The reformulation is defined component-wise as
<P></P><DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{eqnarray*}
\Phi_i(x) := \left\{ \begin{array}{ll}
   \phi(x_i - l_i, F_i(x)) & \mbox{if } -\infty < l_i < u_i = \infty, \\
   -\phi(u_i-x_i, -F_i(x)) & \mbox{if } -\infty = l_i < u_i < \infty, \\
   \phi(x_i - l_i, \phi(u_i - x_i, - F_i(x))) & \mbox{if } -\infty < l_i < u_i < \infty, \\
   -F_i(x) & \mbox{if } -\infty = l_i < u_i = \infty, \\
   l_i - x_i & \mbox{if } -\infty < l_i = u_i < \infty.
   \end{array} \right.
\end{eqnarray*}
 -->
<IMG
 WIDTH="496" HEIGHT="115" BORDER="0"
 SRC="img260.gif"
 ALT="\begin{eqnarray*}
\Phi_i(x) := \left\{ \begin{array}{ll}
\phi(x_i - l_i, F_i(x)...
... &amp; \mbox{if } -\infty &lt; l_i = u_i &lt; \infty.
\end{array} \right.
\end{eqnarray*}"></DIV><BR CLEAR="ALL"><P></P>
<BR CLEAR="ALL"><P></P>
We note that <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img261.gif"
 ALT="$\Phi$"></SPAN> is not differentiable everywhere, but satisfies a
semismoothness property 
[<A
 HREF="manual.html#mifflin:semismooth">19</A>,<A
 HREF="manual.html#qi:convergence">26</A>,<A
 HREF="manual.html#qi.sun:nonsmooth">27</A>].  Furthermore,
the natural merit function, <!-- MATH
 $\Psi(x) := \frac{1}{2} \| \Phi(x) \|_2^2$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="141" HEIGHT="40" ALIGN="MIDDLE" BORDER="0"
 SRC="img262.gif"
 ALT="$\Psi(x) := \frac{1}{2} \Vert \Phi(x) \Vert _2^2$"></SPAN>, is 
continuously differentiable.

<P>
The two semismooth TAO solvers both solve the system <SPAN CLASS="MATH"><IMG
 WIDTH="72" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img263.gif"
 ALT="$\Phi(x) = 0$"></SPAN> by applying
a nonsmooth newton method with a line-search.  We calculate a direction, <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img264.gif"
 ALT="$d^k$"></SPAN>,
by solving the system <!-- MATH
 $H^kd^k = -\Phi(x^k)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="126" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="img265.gif"
 ALT="$H^kd^k = -\Phi(x^k)$"></SPAN> where <SPAN CLASS="MATH"><IMG
 WIDTH="28" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img266.gif"
 ALT="$H^k$"></SPAN> is an element of the 
<SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img267.gif"
 ALT="$B$"></SPAN>-subdifferential [<A
 HREF="manual.html#qi.sun:nonsmooth">27</A>] of <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img268.gif"
 ALT="$\Phi$"></SPAN> at <SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img269.gif"
 ALT="$x^k$"></SPAN>.  If the 
direction calculated does not satisfy a suitable descent condition, then 
we use the negative gradient of the merit function, <!-- MATH
 $-\nabla \Psi(x^k)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="77" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="img270.gif"
 ALT="$-\nabla \Psi(x^k)$"></SPAN>, as 
the search direction.  A standard Armijo search [<A
 HREF="manual.html#armijo:minimization">1</A>] is
used to find the new iteration.  Non-monotone searches 
[<A
 HREF="manual.html#grippo.lampariello.ea:nonmonotone">11</A>] are also available by setting 
appropriate run-time options.  See Section <A HREF="#sec:TaoLineSearch">6.2</A> for further 
details.

<P>
The first semismooth algorithm available in TAO is not guaranteed to 
remain feasible with respect to the bounds, <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img271.gif"
 ALT="$[\ell, u]$"></SPAN>, and is termed 
an infeasible semismooth method.  This method can be specified using the 
TaoMethod <TT>tao_ssils</TT>.  In this case, the descent test used is 
that
<P></P><DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{eqnarray*}
\nabla \Psi(x^k)^Td^k \leq -\delta\| d^k \|^\rho.
\end{eqnarray*}
 -->
<IMG
 WIDTH="178" HEIGHT="31" BORDER="0"
 SRC="img272.gif"
 ALT="\begin{eqnarray*}
\nabla \Psi(x^k)^Td^k \leq -\delta\Vert d^k \Vert^\rho.
\end{eqnarray*}"></DIV><BR CLEAR="ALL"><P></P>
<BR CLEAR="ALL"><P></P>
Both <SPAN CLASS="MATH"><IMG
 WIDTH="44" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img273.gif"
 ALT="$\delta &gt; 0$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="45" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img274.gif"
 ALT="$\rho &gt; 2$"></SPAN> can be modified using the
run-time commands <TT>-tao_ssils_delta &lt;delta&gt;</TT> and 
<TT>-tao_ssils_rho &lt;rho&gt;</TT> respectively. By default, 
<!-- MATH
 $\delta = 10^{-10}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="78" HEIGHT="21" ALIGN="BOTTOM" BORDER="0"
 SRC="img275.gif"
 ALT="$\delta = 10^{-10}$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="58" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img276.gif"
 ALT="$\rho = 2.1$"></SPAN>.

<P>
An alternative is to remain feasible with respect to the bounds by using a 
projected Armijo line-search.  This method can be specified using the 
TaoMethod <TT>tao_ssfls</TT>.  The descent test used is the same as above 
where the direction in this case corresponds to the first part of the 
piece-wise linear arc searched by the projected line-search.  
Both <SPAN CLASS="MATH"><IMG
 WIDTH="44" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img277.gif"
 ALT="$\delta &gt; 0$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="45" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img278.gif"
 ALT="$\rho &gt; 2$"></SPAN> can be modified using the run-time 
commands  <TT>-tao_ssfls_delta &lt;delta&gt;</TT> and <TT>-tao_ssfls_rho &lt;rho&gt;</TT> 
respectively.  By default, <!-- MATH
 $\delta = 10^{-10}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="78" HEIGHT="21" ALIGN="BOTTOM" BORDER="0"
 SRC="img279.gif"
 ALT="$\delta = 10^{-10}$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="58" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img280.gif"
 ALT="$\rho = 2.1$"></SPAN>.

<P>
The recommended algorithm is the infeasible semismooth method,
<TT>tao_ssils</TT>, because of its strong global and local convergence 
properties.  However, if it is known that <SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img281.gif"
 ALT="$F$"></SPAN> is not defined outside 
of the box, <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img282.gif"
 ALT="$[\ell,u]$"></SPAN>, perhaps due to the presence of <SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img283.gif"
 ALT="$log$"></SPAN> functions,
the feasible algorithm, <TT>tao_ssfls</TT>, is a reasonable alternative.

<P>


<P>

<H1><A NAME="SECTION00500000000000000000"></A>
<A NAME="2891"></A>
<A NAME="chapter:taoapplication"></A><A NAME="chapter:petscapp"></A><BR>
TAO Applications using PETSc
</H1>

<P>
The solvers in TAO address applications that have a set of variables, an objective
function, and constraints on the variables.  Many solvers also require derivatives
of the objective and constraint functions.
To use the TAO solvers, the application developer must 
define a set of variables, implement routines that evaluate the 
objective function and constraint functions, and pass this information
to a TAO application object.   

<P>
TAO uses vector and matrix objects to pass this information from the
application to the solver.   The set of variables, for instance, is
represented in a vector.
The gradient of an objective function <!-- MATH
 $f: \, \mathbb{R}^n \to \mathbb{R}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="93" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img284.gif"
 ALT="$f: \, \mathbb{R}^n \to \mathbb{R}$"></SPAN>,
evaluated at a point, is also represented as a vector.
Matrices,  on the other hand,
can be used to represent the Hessian of <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img285.gif"
 ALT="$f$"></SPAN> or the Jacobian of a constraint
function <!-- MATH
 $c: \, \mathbb{R}^n \to \mathbb{R}^m$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="103" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img286.gif"
 ALT="$c: \, \mathbb{R}^n \to \mathbb{R}^m$"></SPAN>.  The TAO solvers use
these objects to compute a solution to the application.

<P>
The PETSc package provides parallel and serial implementations of these
objects and offers additional tools intended for high-performance 
scientific applications.
The <B>Vec</B> and <B>Mat</B> types in PETSc
represent the vectors and matrices in a TAO application.
This chapter will describe how to create these an application object
and give it the necessary properties.  This chapter will also describe how to use
the TAO solvers in conjunction with this application object.

<P>

<H1><A NAME="SECTION00510000000000000000">
Header File</A>
</H1>

<P>
TAO applications written in C/C++ should have the statement 
<PRE>
   #include "tao.h"
</PRE>

in each file that uses a routine in the TAO libraries.
All of the required lower level include files such as ``tao_solver.h''
and ``taoapp.h''
are automatically included within this high-level file.

<P>

<H1><A NAME="SECTION00520000000000000000">
Create and Destroy</A>
</H1>
To create an application object, first
declare a <TT>TAO_APPLICATION</TT> variable.
This variable is only a pointer.  
The application object associated with it can be created using
the routine <A NAME="2892"></A>
<PRE>
   TaoApplicationCreate(MPI_Comm, TAO_APPLICATION*);
</PRE>

Much like creating PETSc vector and matrix objects, 
the first argument is an MPI <EM>communicator</EM>.
An MPI [<A
 HREF="manual.html#using-mpi">13</A>] communicator
indicates a collection of processors that will be used to evaluate the
objective function, compute constraints, and provide derivative information.
When only one processor is being used, the communicator <TT>MPI_COMM_SELF</TT>
can be used with no understanding of MPI.
Even parallel users need to be familiar with only the basic concepts 
of message passing and  distributed-memory computing. 
Most applications running TAO in
parallel environments can employ the communicator <TT>MPI_COMM_WORLD</TT> to indicate all processes in a given run.

<P>
The second argument is the address of a  <TT>TAO_APPLICATION</TT> variable.  This
routine will create a new application object and set the variable, which is a pointer,
to the address of the object.   This application variable can now be used
by the developer to define the application and by the 
TAO solver to solve the application.

<P>
Elsewhere in this chapter, the <TT>TAO_APPLICATION</TT> variable will be referred
to as the <EM>application object</EM><A NAME="2893"></A>.

<P>
After solving the application, the command <A NAME="2894"></A>
<PRE>
   TaoAppDestroy(TAO_APPLICATION);
</PRE>

will destroy the application object and free 
the work space associated with it.

<P>

<H1><A NAME="SECTION00530000000000000000">
Defining Variables</A>
</H1>

<P>
In all of the optimization solvers, the application must provide
a <B>Vec</B> object of appropriate dimension to represent the variables.
This vector will be cloned by the solvers to create additional work
space within the solver.
If this vector is distributed over multiple processors, it
should have a parallel distribution that allows
for efficient scaling, inner products, and
function evaluations.  This vector can be passed to the
application object using the routine <A NAME="2895"></A>
<PRE>
   TaoAppSetInitialSolutionVec(TAO_APPLICATION,Vec);
</PRE>
When using this routine, the application should initialize the vector with
an approximate solution of the optimization problem before calling the
TAO solver.   If you do not know of a solution that that can be used,
the routine
<A NAME="2896"></A>
<TT>TaoAppSetDefaultSolutionVec(TAO_APPLICATION,Vec);</TT>
can be used to declare variables that will in
be set to zero or some other default solution.  

<P>
This vector will be used by the TAO solver to store the solution.
Elsewhere in the application, 
this solution vector can be retieved from the application object 
using the routine <A NAME="2897"></A>
<PRE>
   TaoAppGetSolutionVec(TAO_APPLICATION, Vec *);
</PRE>
This routine takes the address of a <TT>Vec</TT> in the second argument and sets it to
the solution vector used in the application.

<P>

<H1><A NAME="SECTION00540000000000000000"></A>  <A NAME="2898"></A><BR>
Application Context
</H1>
Writing an application using the <TT>TAO_APPLICATION</TT> object may require
use of an <EM>application context</EM>.
An application context is a structure or object defined by an
application developer, passed
into a routine also written by the application developer, 
and used within the routine to perform its stated task.

<P>
For example, a routine that evaluates an objective function may need
parameters, work vectors, and other information.   This information,
which may be specific to an application and necessary to evaluate the objective,
can be collected in a single structure and used as one of the
arguments in the routine.
The address of this structure will be cast as type <TT>(void*)</TT> and passed to
the routine in the final argument.
There are many examples of these structures in the TAO distribution.

<P>
This technique offers several advantages.
In particular, it allows for a uniform interface between TAO and 
the applications.   The fundamental information needed by TAO 
appears in the arguments of the routine, while data specific to an application
and its implementation is confined to an opaque pointer.
The routines can access information created outside the 
local scope without the use of global variables.
The TAO solvers and application objects will never access this structure, 
so the application developer has complete freedom to define it.  In fact,
these contexts are completely optional - a NULL pointer can be used.

<P>

<H1><A NAME="SECTION00550000000000000000"></A><A NAME="sec:fghj"></A><BR>
Objective Function and Gradient Routines
</H1>

<P>
TAO solvers that minimize an objective function require
the application to evaluate the objective function.  Some solvers
may also require the application to evaluate
derivatives of the objective function.  
Routines that perform these computations must be identified
to the application object and must follow a strict calling sequence.

<P>
Routines that evaluate an objective function <!-- MATH
 $f: \, \mathbb{R}^n \to \mathbb{R}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="93" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img287.gif"
 ALT="$f: \, \mathbb{R}^n \to \mathbb{R}$"></SPAN>,
should follow the form:
<PRE>
   EvaluateObjective(TAO_APPLICATION,Vec,double*,void*);
</PRE>

The first argument is the application object, the second argument is the
<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img288.gif"
 ALT="$n$"></SPAN>-dimensional vector that identifies where the objective should be evaluated, 
and the fourth argument is an application context.
This routine should use the third argument to return objective value, 
evaluated at the given point
specified the by the vector in the second argument.

<P>
This routine, and the application context, should be passed to the 
application object using
the routine <A NAME="2899"></A>
<PRE>
   TaoAppSetObjectiveRoutine(TAO_APPLICATION,
                             int(*)(TAO_APPLICATION,Vec,double*,void*),
                             void*);
</PRE>

The first argument in this routine is the application object, 
the second argument is a function pointer to the routine that 
evaluates the objective, and the third
argument is the pointer an appropriate application context.  

<P>
Although final argument may point to anything, it must be cast as a <TT>(void*)</TT> type.
This pointer will be passed back to the developer in the fourth argument of the
routine that evaluates the objective.  In this routine, the pointer can be cast
back to the appropriate type.  Examples of these structures and there usage
are provides in the distribution.

<P>
Most TAO solvers also require gradient information from the 
application <A NAME="2900"></A>.
  The gradient of the objective function can be specified in a similar manner.
Routines that evaluate the gradient should have the calling sequence
<PRE>
   EvaluateTheGradient(TAO_APPLICATION,Vec,Vec,void*);
</PRE>

In this routine, the first
argument is the application object, the second argument is the variable
vector, the third argument is the gradient, and the fourth argument is
the user-defined application context.  Only the third argument in this
routine is different from the arguments in the routine that evaluates
the objective function.  The numbers in the gradient vector have no
meaning when passed into this routine, but should represent the gradient
of the objective at the specified point at the end of the routine.
This routine, and the user-defined pointer, can be passed to the application
object using the routine: <A NAME="2901"></A>
<PRE>
   TaoAppSetGradientRoutine(TAO_APPLICATION,
                            int (*)(TAO_APPLICATION,Vec,Vec,void*),
                            void *);
</PRE>

In this routine, the first argument is the application object, the second argument
is the function pointer, and the third object is the application context, cast
to <TT>(void*)</TT>.

<P>
Instead of evaluating the objective and its gradient in separate
routines, TAO also allows the user to evaluate the function and the gradient
at the same routine.  In fact, some solvers are more efficient when
both function and gradient information can be computed in the same routine.
These routines should follow the form
<PRE>
   EvaluateFunctionGradient(TAO_APPLICATION,Vec,double*,Vec,void*);
</PRE>

where the first
argument is the TAO solver, and the second
argument points to the input vector for use in evaluating the
function and gradient. The third argument should return the
function value, while the fourth argument should return the gradient vector,
and the fifth argument is a pointer to a user-defined context.
This context and the name of the routine should be set with the
call: <A NAME="2902"></A>
<PRE>
   TaoAppSetObjectiveAndGradientRoutine(TAO_APPLICATION,
                     int (*)(TAO_APPLICATION,Vec,double*,Vec,void*),
                     void *);
</PRE>

The arguments of this routine are the TAO application, a
function name, and a pointer to a user-defined context.

<P>
The TAO example problems demonstrate the use of these application contexts
as well as specific instances of function, gradient, and Hessian 
evaluation routines.
All of these routines should return the integer <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img289.gif"
 ALT="$0$"></SPAN> after 
successful completion and a nonzero integer if the function
is undefined at that point or an error occurred.

<P>

<H1><A NAME="SECTION00560000000000000000"></A>
<A NAME="sec:matrixfree"></A><A NAME="sec:finitedifference"></A><BR>
Hessian Evaluation
</H1>

<P>
Some optimization routines also require a Hessian matrix from the user.
The routine that evaluates the Hessian should have the form:
<PRE>
   EvaluateTheHessian(TAO_APPLICATION,Vec,Mat*,Mat*,MatStructure*,void*);
</PRE>

The first argument of this routine is a TAO application.  The second
argument is the point at which the Hessian should be evaluated.  The
third argument is the Hessian matrix, and the sixth argument is a
user-defined context.
Since the Hessian matrix is usually used in solving
a system of linear equations, a preconditioner for the matrix is often
needed.  The fourth argument is the matrix that will be used
for preconditioning the linear system.  In most cases, this
matrix will be the same as the Hessian matrix.  The fifth
argument is the flag used to set the Hessian matrix and
linear solver in the routine <TT>KSPSetOperators()</TT>.

<P>
One can set the Hessian evaluation routine by calling <A NAME="2903"></A>
<A NAME="2904"></A>
<PRE>
   int TaoAppSetHessianRoutine(TAO_APPLICATION,
                int (*)(TAO_APPLICATION,Vec,Mat*,Mat*,MatStructure*,void*),
                void *)
</PRE>

The first argument is the TAO application, the second 
argument is the function that evaluates the Hessian, 
and the third argument is a pointer to a user defined context,
cast as a <TT>void*</TT> pointer.

<P>
For solvers that evaluate the Hessian, 
the matrices used to store the Hessian should be set using 
<A NAME="2905"></A>
<PRE>
   TaoAppSetHessianMat(TAO_APPLICATION,Mat,Mat);
</PRE>

The first argument is the TAO application, the second argument is the Hessian
matrix, and the third argument is the preconditioning matrix.  In most applications,
these two matrices will be the same structure.

<P>

<H2><A NAME="SECTION00561000000000000000"></A> <A NAME="2906"></A><BR>
Finite Differences
</H2>
Finite differences approximations can be used to compute the gradient and the
Hessian of an objective
function.  These approximations will slow down the solve considerably and are only 
recommended for checking the accuracy of hand-coded gradients and Hessians.
These routines are 

<P>
<A NAME="2907"></A>
<PRE>
  TaoAppDefaultComputeGradient(TAO_APPLICATION, Vec, Vec, void*);
</PRE>, 

<P>
<A NAME="2908"></A>
<PRE>
   TaoAppDefaultComputeHessian( TAO_APPLICATION, Vec, Mat*, Mat*, 
                                MatStructure*, void*);
</PRE>

and <A NAME="2909"></A>
<PRE>
   TaoAppDefaultComputeHessianColor( TAO_APPLICATION, Vec, Mat*, Mat*, 
                                      MatStructure*, void* );
</PRE>

These routines can be set using <TT>TaoAppSetGradientRoutine()</TT> and 
<TT>TaoAppSetHessianRoutine()</TT> or through the options database.
If finite differencing is used with coloring, the routine <A NAME="2910"></A>
<PRE>
   TaoAppSetColoring(TAO_APPLICATION, ISColoring);
</PRE>

should be used to specify the coloring.

<P>
It is also possible to use finite difference approximations to directly check
the correctness of an application's gradient and/or Hessian evaluation routines.
This can be done using the special TAO solver <TT>tao_fd_test</TT> together with the options
<TT>-tao_test_gradient</TT> or <TT>-tao_test_hessian</TT>.

<P>

<H2><A NAME="SECTION00562000000000000000">
Matrix-Free methods</A>
</H2>
TAO fully supports matrix-free methods. The matrices specified in the
Hessian evaluation routine need not be conventional
matrices; instead, they can point to the data required to implement a
particular matrix-free method.  The matrix-free variant is allowed
<EM>only</EM> when the linear systems are solved by an iterative method
in combination with no preconditioning (<TT>PCNONE</TT> or <TT>-pc_type none</TT>),
a user-provided preconditioner matrix, or a user-provided preconditioner
shell (<TT>PCSHELL</TT>); that is,
obviously matrix-free methods cannot be used if a direct solver is to 
be employed. <A NAME="2911"></A> Details about using matrix-free methods are provided in the
PETSc  Users Manual.

<P>

<H1><A NAME="SECTION00570000000000000000"></A><A NAME="sec:bounds"></A><BR>
Bounds on Variables
</H1>

<P>
Some optimization problems also impose constraints upon the variables.
The constraints may impose simple bounds upon the variables, or
require that the variables satisfy a set of linear or  nonlinear equations.

<P>
The simplest type of constraint upon an optimization problem puts lower
or upper bounds upon the variables. 
Vectors that represent lower and upper bounds for each variable 
can be set with the command  <A NAME="2912"></A><A NAME="2913"></A>
<PRE>
   TaoAppSetVariableBoundsRoutine(TAO_APPLICATION, 
                          int (*)(TAO_APPLICATION, Vec,Vec,void*),void *);
</PRE>

The first vector and second vectors should contain the lower and upper 
bounds, respectively.
When no upper or lower bound exists for a variable, the bound
may be set to <TT>TAO_INFINITY</TT> or <TT>TAO_NINFINITY</TT>.
After the two bound vectors have been set, they may be accessed with the
with the command  <TT>TaoGetApplicationVariableBounds()</TT>.
Since not all solvers use bounds on variables, the user must be careful 
to select a type of solver that acknowledges these bounds.

<P>

<H1><A NAME="SECTION00580000000000000000"></A><A NAME="sec:constraints"></A><BR>
Complementarity
</H1>

<P>
Constraints in the form of nonlinear equations have the form
<SPAN CLASS="MATH"><IMG
 WIDTH="79" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img290.gif"
 ALT="$C(X) = 0$"></SPAN> where <!-- MATH
 $C: \mathbb{R}^n \to \mathbb{R}^m$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="106" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img291.gif"
 ALT="$C: \mathbb{R}^n \to \mathbb{R}^m$"></SPAN>.
These constraints should be specified in a 
routine, written by the user, that evaluates <TT>C(X)</TT>.
The routine that evaluates the constraint equations should have the form:
<PRE>
   int EqualityConstraints(TAO_APPLICATION,Vec,Vec,void*);
</PRE>

The first argument of this routine is a TAO application object.  The second argument
is the variable vector at which the constraint function should be evaluated.  
The third argument is the vector of function values <TT>C</TT>, and the fourth
argument is a pointer to a user-defined context.
This routine  and the user-defined context 
should be set in the TAO solver with the command
<A NAME="2914"></A>
<PRE>
   TaoAppSetConstraintRoutine(TAO_APPLICATION,
                               int (*)(TAO_APPLICATION,Vec,Vec,void*),
                               void*);
</PRE>

In this function, first argument is the TAO application,
the second argument is vector in which to store the function values,
and the third argument is a pointer to a user-defined context that will
be passed back to the user.

<P>
The Jacobian of the function <TT>C</TT> is the matrix in <!-- MATH
 $\mathbb{R}^{m \times n}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="48" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img292.gif"
 ALT="$\mathbb{R}^{m \times n}$"></SPAN>
such that each column contains the partial derivatives of <TT>f</TT> with respect
to one variable. 
The evaluation of the Jacobian of <TT>f</TT> should be performed in a routine
of the form
<PRE>
   int J(TAO_APPLICATION,Vec,Mat*,Mat*,MatStructure*,void*);
</PRE>

In this function, the second argument is the variable vector at which to 
evaluate the Jacobian matrix, the third argument is the Jacobian matrix,
and the sixth argument is a pointer to a user-defined context.
This routine should be specified using
<A NAME="2915"></A>
<PRE>
   TaoAppSetJacobianRoutine(TAO_APPLICATION,Mat,
                int (*)(TAO_APPLICATION,Vec,Mat*,Mat*, MatStructure*,void*), 
                void*);
</PRE>

The first argument is the TAO application, the second
argument is the matrix in which the information can be stored,
the third argument is the function pointer, and the fourth argument is
an optional user-defined context.
The Jacobian matrix should be created in a way such that the product of 
it and the variable vector can be put in the constraint vector.

<P>
For solvers that evaluate the Jacobian, 
the matrices used to store the Jacobian should be set using 
<A NAME="2916"></A>
<PRE>
   TaoAppSetJacobianMat(TAO_APPLICATION,Mat,Mat);
</PRE>

The first argument is the TAO application, the second argument is the Jacobian
matrix, and the third argument is the preconditioning matrix.  In most applications,
these two matrices will be the same structure.

<P>

<H1><A NAME="SECTION00590000000000000000">
Monitors</A>
</H1>

<P>
By default the TAO solvers run silently without displaying information
about the iterations. The user can initiate monitoring with the
command <A NAME="2917"></A> 
<PRE>
   int TaoSetMonitor(TAO_SOLVER solver,
                     int (*mon)(TAO_SOLVER tao,void* mctx),
                     void *mctx);
</PRE>

<P>
The routine, <TT>mon</TT> indicates a user-defined monitoring routine
and <TT>mctx</TT> denotes an optional user-defined context for private 
data for the monitor routine.

<P>
The routine set by <TT>TaoAppSetMonitor()</TT> is called once during each
iteration of the optimization solver.  Hence, the
user can employ this routine for any application-specific computations
that should be done after the solution update. 
<A NAME="2918"></A>.
<PRE>
   TaoAppSetMonitor(TAO_APPLICATION, 
                    int (*)(TAO_APPLICATION,void*),void *);
</PRE>

<P>

<H1><A NAME="SECTION005100000000000000000"></A><A NAME="sec:TaoLinearSolvers"></A><BR>
Linear Solvers
</H1>
One of the most computationally intensive phases of many optimization
algorithms involves the solution of systems of linear equations.  
The performance
of the linear solver may be critical to an efficient computation
of the solution.
Since linear equation solvers often have a wide variety of options 
associated with them, TAO allows the user to access the linear
solver with the command

<P>
<A NAME="2919"></A>
<PRE>
   TaoAppGetKSP(TAO_APPLICATION, KSP *);
</PRE>

<P>
With access to the KSP object, users can customize it for their application
to achieve additional performance.

<P>

<H1><A NAME="SECTION005110000000000000000">
Application Solutions</A>
</H1>
Once the application object has the 
objective function, constraints, derivatives, and other features associated with it,
a TAO solver can be applied to the application.  
For further information about how to create a TAO solver, see the previous chapter.

<P>
Once the TAO solver and TAO application object have been created and customized, 
they can be matched with one another
using the routine <A NAME="2920"></A>
<PRE> 
   TaoSetupApplicationSolver( TAO_APPLICATION, TAO_SOLVER);
</PRE>

This routine will set up the TAO solver for the application.  
Different solvers may set up differently, but they typically
create the work vectors and linear solvers needed to find a solution.  
These structures were not created
during the creation of the solver because the size of the application
was not known.
After calling this routine
the routine <TT>TaoAppGetTaoSolver()</TT> can be used to obtain
the TAO solver object.  If not called directly by the application, 
<TT>TaoSetupApplicationSolver()</TT> will be executed inside of the
subroutine <TT>TaoSolveApplication()</TT>.

<P>
The routine <A NAME="2921"></A>
<PRE>
   TaoGetGradientVec( TAO_SOLVER, Vec*);
</PRE>

will set a pointer to a <TT>Vec</TT> to the vector object containing
the gradient vector and the <A NAME="2922"></A> routine
<PRE>
   TaoGetVariableBoundVecs( TAO_SOLVER, Vec*, Vec*);
</PRE>

will set the pointers to the lower and upper bounds on the variables  - if 
they exist.  These vectors may be viewed at before, during, and after
the solver is running.

<P>
Options for the application and solver 
can be be set from the command line using the routine <A NAME="2923"></A> <A NAME="2924"></A>
<PRE>
   TaoSetOptions( TAO_APPLICATION, TAO_SOLVER);
</PRE>
This routine will call  <TT>TaoSetupApplicationSolver()</TT> if it has not been
called already.
This command also provides information about runtime options when the
user includes the <TT>-help </TT> option on the
command line.

<P>
Once the application and solver have been set up, the solver can be called using the routine
<A NAME="2925"></A>
<PRE>
   TaoSolveApplication( TAO_APPLICATION, TAO_SOLVER);
</PRE>

This  routine will call the TAO solver.  If the routine  <TT>TaoSetupApplicationSolver()</TT>
has not already been called, this routine will call it.

<P>
After a solution has been found, the routine
<PRE>
   TaoCopyDualsOfVariableBounds( TAO_APPLICATION, Vec, Vec );
</PRE>

can compute the dual values of the variables bounds and copy them
into the vectors passed into this routine.

<P>

<H1><A NAME="SECTION005120000000000000000">
Linear Algebra Abstractions</A>
</H1>

<P>
Occasionally TAO users will have to interact directly with the linear
algebra objects used by the solvers.   Solvers within TAO use 
vector, matrix, index set, and linear solver objects that have no
native data structures. Instead they have methods whose implementation
is uses structures and routines provided by PETSc or other external
software packages.

<P>
Given a PETSc <TT>Vec</TT> object <TT>X</TT>, the user can create a <TT>TaoVec</TT> object. <A NAME="2926"></A>
By declaring the variables 
<PRE>
   TaoVec *xx;
</PRE>

the routine
<PRE>
   TaoWrapPetscVec(Vec,TaoVec **);
</PRE>

takes the <TT>Vec x</TT> and creates and sets <TT>TaoVec *xx</TT> equal to
a new <TT>TaoVec</TT> object.   This object actually has the derived
type <TT>TaoVecPetsc</TT>.
Given a <TT>TaoVec</TT> whose underlying representation is a PETSc <TT>Vec</TT>,
the command
<PRE>
   TaoVecGetPetscVec( TaoVec *, Vec *);
</PRE>

will retrieve the underlying vector.
The routine <TT>TaoVecDestroy()</TT> will destroy the <TT>TaoVec</TT> object,
but the <TT>Vec </TT> object must also be destroyed.

<P>
The routine <A NAME="2927"></A>
<PRE>
   TaoWrapPetscMat(Mat,TaoMat **);
</PRE>

takes the <TT>Mat H</TT> and creates and sets <TT>TaoMat *HH</TT> equal to
the new <TT>TaoMat</TT> object.   The second argument specifies whether
the <TT>Mat</TT> object should be destroyed when the <TT>TaoVec</TT> object
is destroy.
This object actually has the derived
type <TT>TaoMatPetsc</TT>.
Given a <TT>TaoMat</TT> whose underlying representation is a PETSc <TT>Vec</TT>,
the command
<PRE>
   TaoMatGetPetscMat( TaoMat *, Mat *);
</PRE>

will retrieve the underlying matrix.
The routine <TT>TaoMatDestroy()</TT> will destroy the <TT>TaoMat</TT> object,
but the <TT>Mat </TT> object must also be destroyed.

<P>
Similarly, the routine <A NAME="2928"></A>
<PRE>
   TaoWrapKSP( KSP, TaoLinearSolver **);
</PRE>

takes a <TT>KSP </TT> object and creates a  <TT>TaoLinearSolver</TT>
object.  The 
<PRE>
   TaoLinearSolverGetKSP( TaoLinearSolver *, KSP *);
</PRE>

gets the underlying <TT>KSP</TT> object from the <TT>TaoLinearSolver</TT>
object.

<P>
For index sets, the routine
<PRE>
   TaoWrapPetscIS( IS, int, TaoIndexSet **);
</PRE>

creates a <TT>TaoIndexSet</TT> object.  In this routine, however, the
second argument is the local size of the vectors that this object
will describe.  For instance, this object may describe with
elements of a vector are positive.  The second argument should
be be local length of the vector.  The <TT>IS</TT> object will
be destroyed when the <TT>TaoIndexSet</TT> is destroyed.  The routine
<PRE>
   TaoIndexSetGetPetscIS( TaoIndexSet *, IS *);
</PRE>

will return the underlying <TT>IS</TT> object.

<P>

<H1><A NAME="SECTION005130000000000000000">
Compiling and Linking</A>
</H1>

<P>
Portable TAO makefiles follow the rules and definitions
of PETSc makefiles.
In Figures <A HREF="#fig:make3">5.1</A> we present a sample makefile.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:make3"></A><A NAME="2820"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5.1:</STRONG>
Sample TAO makefile for a single C program</CAPTION>
<TR><TD><IMG
 WIDTH="511" HEIGHT="168" BORDER="0"
 SRC="img293.gif"
 ALT="\begin{figure}{\footnotesize
\begin{verbatim}
CFLAGS =
FFLAGS =
CPPFLAGS ...
...IB} ${PETSC_SNES_LIB}
${RM} minsurf1.o\end{verbatim}
\noindent
}\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>
This small makefile is suitable for maintaining a single program that
uses the TAO library.  The most important line in this makefile is the
line starting with <TT>include</TT>:

<P>
<PRE>
   include ${TAO_DIR}/bmake/tao_common
</PRE>
<A NAME="2929"></A>
This line includes other makefiles that provide the needed definitions
and rules for the particular base software installations (specified by
<TT>${TAO_DIR}</TT> and <TT>${PETSC_DIR}</TT>) and architecture
(specified by <TT>${PETSC_ARCH}</TT>), which are typically set as
environmental variables prior to compiling TAO source or programs.  As
listed in the sample makefile, the appropriate <TT>include</TT> file is
automatically completely specified; the user should <EM>not</EM> alter
this statement within the makefile.

<P>
TAO applications using PETSc should be linked with the
to the <TT>PETSC_SNES_LIB</TT> library
as well as the <TT>TAO_LIB</TT> library. This version uses
PETSc 3.1, and the <TT>PETSC_DIR</TT> variable
should be set accordingly.  Many examples of makefiles
can be found in the <TT>examples</TT> directories.

<P>

<H1><A NAME="SECTION005140000000000000000"></A>
<A NAME="chapter:petscfapp"></A><BR>
TAO Applications using PETSc and FORTRAN
</H1>

<P>
Most of the functionality of TAO can be obtained by people who program
purely in Fortran 77 or Fortran 90.  Note, however, that we recommend
the use of C and/or C++ because these languages contain several
extremely powerful concepts that the Fortran77/90 family does not.
The TAO Fortran interface works with both F77 and F90 compilers.

<P>
Since Fortran77 does not provide type checking of routine input/output
parameters, we find that many errors encountered within TAO Fortran
programs result from accidentally using incorrect calling sequences.
Such mistakes are immediately detected during compilation when using
C/C++.  Thus, using a mixture of C/C++ and Fortran often works well
for programmers who wish to employ Fortran for the core numerical
routines within their applications.  In particular, one can
effectively write TAO driver routines in C++, thereby preserving
flexibility within the program, and still use Fortran when desired for
underlying numerical computations.

<P>
Only a few differences exist between the C and Fortran TAO interfaces,
all of which are due to differences in Fortran syntax.  All Fortran
routines have the same names as the corresponding C versions, and
command line options are fully supported. The routine arguments follow
the usual Fortran conventions; the user need not worry about passing
pointers or values.  The calling sequences for the Fortran version are
in most cases identical to the C version, except for the error
checking variable discussed in Section <A HREF="#sec:fortran_errors">5.14.2</A>.  In
addition, the Fortran routine <TT>TaoInitialize(char *filename,int info)</TT>
differs slightly from its C counterpart; see the manual page for
details.

<P>

<H2><A NAME="SECTION005141000000000000000"></A>
<A NAME="sec:fortran_includes"></A><BR>
Include Files
</H2>

<P>
Currently, TAO users must employ the Fortran file suffix <TT>.F</TT>
rather than <TT>.f</TT>.  This convention enables use of the CPP
preprocessor, which allows the use of the <EM>#include</EM> statements
that define TAO objects and variables. (Familiarity with the CPP
preprocessor is not needed for writing TAO Fortran code; one can
simply begin by copying a TAO Fortran example and its corresponding
makefile.)  

<P>
The TAO directory <TT>${TAO_DIR}/include/finclude</TT>
contains the Fortran include files
and should be used via statements 
such as the following:
<PRE>
    #include "include/finclude/includefile.h"
</PRE>

Since one must be very careful to include each file no more than once
in a Fortran routine, application programmers must manually include
each file needed for the various TAO (or other supplementary)
components within their program.  This approach differs from the TAO
C++ interface, where the user need only include the highest level
file, for example, <TT>tao.h</TT>, which then automatically
includes all of the required lower level files.  As shown in the
various Fortran example programs in the TAO distribution, in Fortran
one must explicitly list <EM>each</EM> of the include files.

<P>

<H2><A NAME="SECTION005142000000000000000"></A>
<A NAME="sec:fortran_errors"></A><BR>
Error Checking
</H2>

<P>
In the Fortran version, each TAO routine has as its final argument
an integer error variable, in contrast to the C++ convention of
providing the error variable as the routine's return value.  The error
code is set to be nonzero if an error has been detected; otherwise, it
is zero.  For example, the Fortran and C++ variants of <TT>TaoSolveApplication()</TT> are
given, respectively, below, where <TT>info</TT> denotes the error variable:
<PRE>
   call TaoSolveApplication(TAO_APPLICATION taoapp, TAO_SOLVER tao, int info)
   info = TaoSolveApplication(TAO_APPLICATION taoapp, TAO_SOLVER tao)
</PRE>

<P>
Fortran programmers can use the error codes in writing their own
tracebacks.  For example, one could use code such as the following:
<PRE>
   call TaoSolveApplication(taoapp, tao, info)
   if (info .ne. 0) then
       print*, 'Error in routine ...'
       return
   endif
</PRE>

In addition, Fortran programmers can check these error codes with the
macro <TT>CHKERRQ()</TT>, which terminates all process when an error
is encountered.  See the PETSc users manual for details.  The most
common reason for crashing PETSc Fortran code is forgetting the final
<TT>info</TT> argument.

<P>
Additional interface differences for Fortran users:

<UL>
<LI><TT>TaoGetConvergenceHistory()</TT> - returns only the number of 
elements in the history.  Storage for the convergence information must 
be preallocated by the user and then registered with 
<TT>TaoSetConvergenceHistory()</TT>.
</LI>
<LI><TT>TaoSetLinesearch()</TT> - use only the first and fourth 
arguments. The setup, options, view, and destroy routines do not apply.
</LI>
</UL>

<P>

<H2><A NAME="SECTION005143000000000000000"></A>
<A NAME="sec:fortcompile"></A><BR>
Compiling and Linking Fortran Programs
</H2>

<P>
Figure <A HREF="#fig:make4">5.2</A> shows a sample makefile that can be used for
TAO Fortran programs.  You can compile a debugging
version of the program <TT>rosenbrock1f</TT> with 
<TT>make rosenbrock1f</TT>.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:make4"></A><A NAME="2873"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5.2:</STRONG>
Sample TAO makefile for a single Fortran program</CAPTION>
<TR><TD><IMG
 WIDTH="631" HEIGHT="185" BORDER="0"
 SRC="img294.gif"
 ALT="\begin{figure}{\footnotesize
\begin{verbatim}
CFLAGS =
FFLAGS =
CPPFLAGS ...
...ETSC_SNES_LIB}
${RM} rosenbrock1f.o\end{verbatim} % $
\noindent
}\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>
Note that the TAO Fortran interface library, given by <TT>${TAO_FORTRAN_LIB}</TT>, <EM>must</EM> <A NAME="2930"></A> precede
the base TAO library, given by <TT>${TAO_LIB}</TT>, <A NAME="2931"></A>
on the link line.

<P>

<H2><A NAME="SECTION005144000000000000000">
Additional Issues</A>
</H2>

<P>
The TAO library currently interfaces to the PETSc library for
low-level system functionality as well as linear algebra support.  The
PETSc users manual discusses additional Fortran issues in these areas,
including

<UL>
<LI>array arguments (e.g., <TT>VecGetArray()</TT>),
</LI>
<LI>calling Fortran Routines from C (and C Routines from Fortran),
</LI>
<LI>passing null pointers,
</LI>
<LI>duplicating multiple vectors, and
</LI>
<LI>matrix and vector indices.
</LI>
</UL>

<P>

<P>

<P>

<P>

<H1><A NAME="SECTION00600000000000000000">
Advanced Options</A>
</H1>

<P>
This section discusses options and routines that apply to all TAO
solvers and problem classes.  In particular, we focus on
convergence tests and line searches.

<P>

<H1><A NAME="SECTION00610000000000000000"></A>
<A NAME="sec:Taoconvergence"></A><BR>
Convergence Tests
</H1>

<P>
There are many different ways to define convergence of a solver.
The methods TAO uses by default are mentioned in 
Section <A HREF="#sec:customize">3.3</A>.
These methods include absolute and relative convergence tolerances as well
as a maximum number of iterations of function evaluations.
If these choices are not sufficient, 
the user can even specify a customized test<A NAME="3381"></A>. 

<P>
Users can set their own customized convergence tests of the form
<PRE>
   int  conv(TAO_SOLVER tao, void *cctx);
</PRE>

The second argument
is a pointer to a structure defined by the user.
Within this routine, the solver
can be queried for the solution vector, gradient vector,
or other statistic at the current iteration through routines such as
<TT>TaoGetSolutionStatus()</TT> and  <TT>TaoGetTolerances()</TT>.

<P>
To use this convergence test within a TAO solver, use
the command <A NAME="3382"></A>
<PRE>
      int TaoSetConvergenceTest(TAO_SOLVER solver,
                                int (*conv)(TAO_SOLVER tao,
                                            void *cctx),
                                void *cctx);
</PRE>

The second argument of this command is the convergence routine, and the
final argument of the convergence test routine, <TT>cctx</TT>,
denotes an optional user-defined context for private data.  
The convergence routine receives the TAO solver and this private data
structure. 
The termination flag can be set using the routine
<PRE>
   int TaoSetTerminationReason(TAO_SOLVER , TaoTerminationReason*);
</PRE>

<P>

<H1><A NAME="SECTION00620000000000000000"></A> <A NAME="3383"></A>
<A NAME="sec:TaoLineSearch"></A><BR>
Line Searches
</H1>

<P>
Many solver in TAO require a line search.  While these solver always
offer a default line search, alternative line searches can also be used.
Line searches must have the form:
<PRE>
    int L(TAO_SOLVER tao,TaoVec *xx,TaoVec *gg,TaoVec *dx, TaoVec *ww,
          double *f, double *step,double *gdx,int *flg,void *lsctx);
</PRE>
In this routine the first argument is the TAO solver, the second argument
is the current solution vector, the third argument is the gradient at
the current point, the fourth argument is the step direction, the fourth
vector is a work vector, the fifth argument is the function value, the
sixth argument is the step length, the seventh argument is the inner
product of the gradient and direction vector used for the Armijo condition,
the eighth argument is a flag indicating success or
failure of the line search, and the last argument is a pointer to
a structure that can be used to define the line search.  When the 
routine is finished the solution vector <TT>xx</TT>, gradient vector <TT>gg</TT>, 
function value <TT>f</TT>, step size <TT>step</TT>, and <TT>flg</TT> should be
updated to reflect the new solution.

<P>
This routine can be set with the function <A NAME="3384"></A>
<PRE>
   int TaoSetLineSearch(TAO_SOLVER solver, 
                  int (*setup)(TAO_SOLVER, void*),
		  int (*options)(TAO_SOLVER,void*),
                  int (*line)(TAO_SOLVER,TaoVec*,TaoVec*,TaoVec*,TaoVec*,
                           double*,double*,double*,int*,void*),
                  int (*viewit)(TAO_SOLVER,void*),
		  int (*destroy)(TAO_SOLVER,void*),
                  void *ctx);
</PRE>

In this routine, the fourth argument is the function pointer to the line
search routine, and the seventh argument is the pointer that will be passed
to the line search routine.  The other arguments are optional function 
pointers than can be used to set up, view, and deallocate the solver.

<P>

<P>

<P>

<P>

<H1><A NAME="SECTION00700000000000000000"></A>
<A NAME="chapter:addsolver"></A><BR>
Adding a solver
</H1>

<P>

<H1><A NAME="SECTION00710000000000000000">
Adding a Solver to TAO</A>
</H1>

<P>
New optimization solvers can be added to TAO.  TAO provides tools for
facilitate the implementation of a solver.  The advantages of implementing
a solver using TAO are several.

<P>

<OL>
<LI>TAO includes other optimization solvers with an identical interface, 
so application problems may
conveniently switch solvers to compare their effectiveness.

<P>
</LI>
<LI>TAO provides support for function evaluations and
derivative information.  It allows for the direct evaluation
of this information by the application developer, 
and contains limited support for finite difference, and
allows the uses of matrix-free methods.
The solvers can obtain this function and derivative information
through a simple interface  while the details of its computation 
are handled within the toolkit.

<P>
</LI>
<LI>TAO provides line searches, convergence
tests, monitoring routines, and other tools
which are helpful within an optimization algorithm.
The availability
of these tools means that the developers of the optimization
solver do not have to write these utilities.

<P>
</LI>
<LI>TAO offers vectors, matrices, index sets, and linear solvers
that can be used by the solver.  These objects are standard mathematical
constructions that have many different implementations.
The objects may be distributed over multiple processors, restricted to
a single processor, have a dense representation, 
use a sparse data structure, or vary in many other ways.  
TAO solvers do not need to know how
these objects are represented or how the operations defined on them
have been implemented.  Instead, the solvers apply these operations
through an abstract interface that leaves the details to TAO
and external libraries.
This abstraction allows solvers to work seamlessly with a variety
of data structures while allowing application developers to select 
data structures tailored for their purposes.

<P>
</LI>
<LI>TAO supports an interface to PETSc and
allows the integration of other libraries as well.
When used with PETSc, TAO provides the user a convenient
method for setting options at runtime, performance profiling, and debugging.

<P>
</LI>
</OL>

<P>

<H1><A NAME="SECTION00720000000000000000">
TAO Interface with Solvers</A>
</H1>
TAO solvers must be written in C++ and include several routines with
a particular calling sequence.  Two of these routines are mandatory:
one that initializes the TAO structure with the appropriate information
and one that applies the algorithm to a problem instance.
Additional routines may be written to set some options within the
solver, view the solver, setup appropriate data structures, and destroy
these data structures.
In each of these routines except the initialization routine, 
there are two arguments.  

<P>
The first argument
is always the TAO structure.  This structure may be used to obtain the
vectors used to store the variables and the function gradient, evaluate
a function and gradient, solve a set of linear equations, perform a line 
search, and apply a convergence test.

<P>
The second argument is specific to this solver.  This pointer will be set
in  the initialization routine and cast to an appropriate type in
the other routines.  To implement the Fletcher - Reeves conjugate
gradient algorithm, for instance, the following structure may
be useful.
<PRE>
typedef struct{

  double beta;

  TaoVec *gg;
  TaoVec *dx;   /* step direction */
  TaoVec *ww;   /* work vector    */

} TAO_CG;
</PRE>
This structure contains two work vectors and a scalar.  Vectors
for the solution and gradient are not needed here because the TAO
structure has pointers to them.

<P>

<H2><A NAME="SECTION00721000000000000000">
Solver Routine</A>
</H2>
All TAO solvers have a routine that accepts a TAO structure and
computes a solution.  
TAO will call this routine when the application
program uses the routine <TT>TaoSolve()</TT> and pass to the solver
information
about the objective function and constraints, pointers to the
variable vector and gradient vector, and support for line searches,
linear solvers, and convergence monitoring.  As an example, consider
the following code which solves an unconstrained minimization problem
using the Fletcher-Reeves conjugate gradient method.

<P>
<PRE>
static int TaoSolve_CG_FR(TAO_SOLVER tao, void *solver){

  TAO_CG  *cg = (TAO_CG *) solver;
  TaoVec  *xx,*gg=cg-&gt;gg;    /* solution vector, gradient vector */
  TaoVec  *dx=cg-&gt;dx, *ww=cg-&gt;ww;
  int     iter=0,lsflag=0,info;
  double  gnormPrev,gdx,f,gnorm,step=0;
  TaoTerminateReason reason;

  TaoFunctionBegin;
  info=TaoCheckFG(tao);CHKERRQ(info);
  info=TaoGetSolution(tao,&amp;xx);CHKERRQ(info);

  info = TaoComputeMeritFunctionGradient(tao,xx,&amp;f,gg);CHKERRQ(info);
  info = gg-&gt;Norm2(&amp;gnorm);  CHKERRQ(info);

  info = dx-&gt;SetToZero(); CHKERRQ(info); 

  cg-&gt;beta=0;
  gnormPrev = gnorm;

  /* Enter loop */
  while (1){

    /* Test for convergence */
    info = TaoMonitor(tao,iter++,f,gnorm,0.0,step,&amp;reason);CHKERRQ(info);
    if (reason!=TAO_CONTINUE_ITERATING) break;

    cg-&gt;beta=(gnorm*gnorm)/(gnormPrev*gnormPrev);
    info = dx-&gt;Axpby(-1.0,gg,cg-&gt;beta); CHKERRQ(info);
    
    info = dx-&gt;Dot(gg,&amp;gdx); CHKERRQ(info);
    if (gdx&gt;=0){     /* If not a descent direction, use gradient */
      cg-&gt;beta=0.0;
      info = dx-&gt;Axpby(-1.0,gg,cg-&gt;beta); CHKERRQ(info);
      gdx=-gnorm*gnorm;
    } 

    /* Line Search */
    gnormPrev = gnorm;  step=1.0;
    info = TaoLineSearchApply(tao,xx,gg,dx,ww,&amp;f,&amp;step,&amp;lsflag);
    info = gg-&gt;Norm2(&amp;gnorm);CHKERRQ(info);

  }
  
  TaoFunctionReturn(0);
}
</PRE>

<P>
The first line of this routine cast the second argument to a pointer
to a <TT>TAO_CG</TT> data structure.  This structure contains pointers
to three vectors and a scalar which will be needed in the algorithm.

<P>
After declaring an initializing several variables, the solver first
checks that the function and gradient have been defined using the
routine <TT>TaoCheckFG()</TT>.  Next, the solver gets the variable
vector which was passed to TAO by the application program.
Other solvers may also want to get pointers to Hessian matrices,
Jacobian matrices, or vectors containing bounds on the variables.
The commands for these routines are
<TT>TaoGetSolution()</TT>, <TT>TaoGetVariableBounds()</TT>, 
<TT>TaoGetHessian()</TT>, and <TT>TaoGetJacobian()</TT>.

<P>
This solver lets TAO evaluate the function and gradient at the
current point in the using the routine <TT>TaoComputeFunctionGradient()</TT>.
Other routines may be used to evaluate the Hessian matrix or evaluate
constraints.  TAO may obtain this information using direct evaluation 
of other means, but the these details do not affect our implementation
of the algorithm.

<P>
The norm of the gradient is a standard measure used
by unconstrained minimization solvers to define convergence.
This quantity is always nonnegative and equals zero at the solution.  
The solver will pass this quantity, the current
function value, the current iteration number, and a measure of
infeasibility to TAO with the routine
<PRE>
   int TaoMonitor(TAO_SOLVER,int,double,double,double,double,
                  TaoTerminateReason*);
</PRE>
Most optimization algorithms are iterative in nature, and solvers should
include this command somewhere in each iteration.  This routine
records this information, applies any monitoring routines and 
convergence tests set by default or the user.

<P>
In this routine, the second argument is the current
iteration number, and the third argument is the current function value.
The fourth argument is a nonnegative error measure associated with the
distance between the current solution and the optimal solution.  Examples
of this measure are the norm of the gradient or the square root of a duality 
gap. The fifth measure is a nonnegative error 
that is nonnegative and usually
represents a residual between the current function value and the
optimal solution, such as the norm of the
gradient.  The sixth argument is a nonnegative steplength, 
or the multiple of the step direction added to the previous iterate.
The results of the convergence test are returned in the last argument.
If the termination reason is <TT>TAO_CONTINUE_ITERATING</TT>, the
algorithm should continue.

<P>
After this monitoring routine, the solver computes a step direction
using methods defined on the TaoVec object.  These methods include
adding vectors together and computing an inner product.  A full list
of these methods can be found in the manual pages.

<P>
Nonlinear conjugate gradient algorithms also require a line search.  TAO
provides several line searches and support for using them.
The routine
<PRE>
   int TaoLineSearchApply(TAO_SOLVER tao, TaoVec *xx, TaoVec *gg, TaoVec *dx,
                          TaoVec *ww, double *f, double *step,
                          int*flag)
</PRE>
passes the current solution, gradient, and objective value to the
solver and returns a new solution, gradient, and objective value.  More
details on line searches can be found in the Section&nbsp;<A HREF="#sec:TaoLineSearch">6.2</A>
The details of this line search are should be specified elsewhere, when
the line search is created.

<P>
TAO also includes support for linear solvers.  Although this algorithm
does not require one, linear solvers are an important part of many
algorithms.  Details on the use of these solvers can be found in
Section&nbsp;<A HREF="#sec:TaoLinearSolvers">5.10</A>.

<P>

<H2><A NAME="SECTION00722000000000000000">
Creation Routine</A>
</H2>
The TAO solver is initialized to for a particular algorithm in a separate
routine.  This routine sets default convergence tolerances, creates a
line search or linear solver if needed, and creates structures needed
by this solver.   For example, the routine that creates the nonlinear
conjugate gradient algorithm shown above can be implemented as follows.
<PRE>
EXTERN_C_BEGIN
int TaoCreate_CG_FR(TAO_SOLVER tao)
{
  TAO_CG *cg;
  int    info;

  TaoFunctionBegin;

  info = TaoNew(TAO_CG,&amp;cg); CHKERRQ(info);

  info = TaoSetMaximumIterates(tao,2000); CHKERRQ(info);
  info = TaoSetTolerances(tao,1e-4,1e-4,0,0); CHKERRQ(info);
  info = TaoSetMaximumFunctionEvaluations(tao,4000); CHKERRQ(info);

  info = TaoCreateMoreThuenteLineSearch(tao,0,0.1); CHKERRQ(info);

  info = TaoSetTaoSolveRoutine(tao,TaoSolve_CG_FR,(void*)cg); CHKERRQ(info);
  info = TaoSetTaoSetUpDownRoutines(tao,TaoSetUp_CG,TaoDestroy_CG); CHKERRQ(info);
  info = TaoSetTaoOptionsRoutine(tao,TaoSetOptions_CG_FR); CHKERRQ(info);
  info = TaoSetTaoViewRoutine(tao,TaoView_CG); CHKERRQ(info);

  TaoFunctionReturn(0);
}
EXTERN_C_END
</PRE>
The first thing this routine does after declaring some variables, is allocate
memory for the <TT>TAO_CG</TT> data structure.  Clones of the the 
variable vector assed into TAO in the <TT>TaoCreate()</TT> routine 
are used as the two work vectors.
This routine also sets some default convergence tolerances and creates
a particular line search.
These defaults could be specified in the routine that solves the problem,
but specifying them here gives the user the opportunity to modify these
parameters.

<P>
Finally, this solvers passes to TAO the names of all the other routines
used by the solver.  

<P>
Note that the lines <TT>EXTERN_C_BEGIN</TT> and <TT>EXTERN_C_END</TT> surround
this routine.  These macros are required to preserve the name of this
function without any name-mangling from the C++ compiler.

<P>

<H2><A NAME="SECTION00723000000000000000">
Destroy Routine</A>
</H2>
Another routine needed by most solvers destroys the data structures
creates by earlier routines.  For the nonlinear conjugate gradient
method discussed earlier, the following routine destroys the two
work vectors, the line search, and the <TT>TAO_CG</TT> structure. 
<PRE>
int TaoDestroy_CG(TAO_SOLVER tao, void *solver)
{
  TAO_CG *cg = (TAO_CG *) solver;
  int    info;

  TaoFunctionBegin;

  info = TaoVecDestroy(cg-&gt;gg); CHKERRQ(info);
  info = TaoVecDestroy(cg-&gt;ww);CHKERRQ(info);
  info = TaoVecDestroy(cg-&gt;dx);CHKERRQ(info);

  info = TaoLineSearchDestroy(tao);CHKERRQ(info);
  TaoFree(cg);

  TaoFunctionReturn(0);
}
</PRE>
Other algorithms may destroy matrices, linear solvers, index sets, or
other objects needed by the solver.  This routine is called from within
the <TT>TaoDestroy()</TT> routine.

<P>

<H2><A NAME="SECTION00724000000000000000">
SetUp Routine</A>
</H2>
If this routine has been set by the initialization routine, TAO
will call it during the <TT>TaoSetApplication()</TT>.  
This routine is optional, but is often a used to allocate
the gradient vector, work vectors, and other data structures 
required by the solver.
It should have the form
<PRE>
int TaoSetUp_CG(TAO_SOLVER,void*);
{
  int    info;
  TaoVec *xx;
  TaoFunctionBegin;

  info = TaoGetSolution(tao,&amp;xx);CHKERRQ(info);
  info = xx-&gt;Clone(&amp;cg-&gt;gg); CHKERRQ(info);
  info = xx-&gt;Clone(&amp;cg-&gt;ww); CHKERRQ(info);
  info = xx-&gt;Clone(&amp;cg-&gt;dx); CHKERRQ(info);
  TaoFunctionReturn(0);
}
</PRE>
The second argument can be cast to the appropriate data structure.
Many solvers use a similar routine to allocate data structures
needed by the solver but not created by the initialization routine.

<P>

<P>
<BR>

<H2><A NAME="SECTION00800000000000000000">
Index</A>
</H2>
<DL COMPACT>
<DD><DT><A NAME="tex2html37"
 HREF="manual.html#2891"><STRONG>application</STRONG></A>
<DT><A NAME="tex2html44"
 HREF="manual.html#2898"><STRONG>application context</STRONG></A>
<DT><A NAME="tex2html39"
 HREF="manual.html#2893"><STRONG>application object</STRONG></A>
<DT><A NAME="tex2html58"
 HREF="manual.html#2912"><STRONG>bounds</STRONG></A>
<A NAME="tex2html33"
 HREF="manual.html#1364">, <STRONG><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.gif"></STRONG></A>
<DT><A NAME="tex2html6"
 HREF="manual.html#691"><STRONG>command line arguments</STRONG></A>
<DT><A NAME="tex2html12"
 HREF="manual.html#697"><STRONG>convergence tests</STRONG></A>
<A NAME="tex2html80"
 HREF="manual.html#3381">, <STRONG><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.gif"></STRONG></A>
<DT><A NAME="tex2html52"
 HREF="manual.html#2906"><STRONG>finite differences</STRONG></A>
<DT><A NAME="tex2html46"
 HREF="manual.html#2900"><STRONG>gradients</STRONG></A>
<A NAME="tex2html22"
 HREF="manual.html#1357">, <STRONG><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.gif"></STRONG></A>
<A NAME="tex2html25"
 HREF="manual.html#1359">, <STRONG><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.gif"></STRONG></A>
<DT><A NAME="tex2html49"
 HREF="manual.html#2903"><STRONG>Hessian</STRONG></A>
<DT><A NAME="tex2html21"
 HREF="manual.html#1356"><STRONG>line search</STRONG></A>
<A NAME="tex2html24"
 HREF="manual.html#1358">, <STRONG><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.gif"></STRONG></A>
<A NAME="tex2html82"
 HREF="manual.html#3383">, <STRONG><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.gif"></STRONG></A>
<A NAME="tex2html27"
 HREF="manual.html#1361">, <STRONG><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.gif"></STRONG></A>
<DT><A NAME="tex2html74"
 HREF="manual.html#2928"><STRONG>linear solver</STRONG></A>
<DT><A NAME="tex2html73"
 HREF="manual.html#2927"><STRONG>matrix</STRONG></A>
<DT><A NAME="tex2html57"
 HREF="manual.html#2911"><STRONG>matrix-free options</STRONG></A>
<DT><A NAME="tex2html30"
 HREF="manual.html#1362"><STRONG>Newton method</STRONG></A>
<A NAME="tex2html26"
 HREF="manual.html#1360">, <STRONG><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.gif"></STRONG></A>
<DT><A NAME="tex2html34"
 HREF="manual.html#1365"><STRONG>Newton's method</STRONG></A>
<A NAME="tex2html36"
 HREF="manual.html#1367">, <STRONG><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.gif"></STRONG></A>
<DT><A NAME="tex2html69"
 HREF="manual.html#2923"><STRONG>options</STRONG></A>
<DT><A NAME="tex2html78"
 HREF="manual.html#2930"><STRONG>TAO_FORTRAN_LIB</STRONG></A>
<DT><A NAME="tex2html79"
 HREF="manual.html#2931"><STRONG>TAO_LIB</STRONG></A>
<A NAME="tex2html76"
 HREF="manual.html#2929">, <STRONG><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.gif"></STRONG></A>
<DT><A NAME="tex2html53"
 HREF="manual.html#2907"><STRONG>TaoAppDefaultComputeGradient()</STRONG></A>
<DT><A NAME="tex2html54"
 HREF="manual.html#2908"><STRONG>TaoAppDefaultComputeHessian()</STRONG></A>
<DT><A NAME="tex2html55"
 HREF="manual.html#2909"><STRONG>TaoAppDefaultComputeHessianColor()</STRONG></A>
<DT><A NAME="tex2html65"
 HREF="manual.html#2919"><STRONG>TaoAppGetKSP()</STRONG></A>
<DT><A NAME="tex2html43"
 HREF="manual.html#2897"><STRONG>TaoAppGetSolutionVec()</STRONG></A>
<DT><A NAME="tex2html38"
 HREF="manual.html#2892"><STRONG>TaoApplicationCreate()</STRONG></A>
<DT><A NAME="tex2html40"
 HREF="manual.html#2894"><STRONG>TaoApplicationDestroy()</STRONG></A>
<DT><A NAME="tex2html56"
 HREF="manual.html#2910"><STRONG>TaoAppSetColoring()</STRONG></A>
<DT><A NAME="tex2html60"
 HREF="manual.html#2914"><STRONG>TaoAppSetConstraintsRoutine()</STRONG></A>
<DT><A NAME="tex2html42"
 HREF="manual.html#2896"><STRONG>TaoAppSetDefaultSolutionVec()</STRONG></A>
<DT><A NAME="tex2html47"
 HREF="manual.html#2901"><STRONG>TaoAppSetGradientRoutine()</STRONG></A>
<DT><A NAME="tex2html51"
 HREF="manual.html#2905"><STRONG>TaoAppSetHessianMat()</STRONG></A>
<DT><A NAME="tex2html50"
 HREF="manual.html#2904"><STRONG>TaoAppSetHessianRoutine()</STRONG></A>
<DT><A NAME="tex2html41"
 HREF="manual.html#2895"><STRONG>TaoAppSetInitialSolutionVec()</STRONG></A>
<DT><A NAME="tex2html62"
 HREF="manual.html#2916"><STRONG>TaoAppSetJacobianMat()</STRONG></A>
<DT><A NAME="tex2html61"
 HREF="manual.html#2915"><STRONG>TaoAppSetJacobianRoutine()</STRONG></A>
<DT><A NAME="tex2html64"
 HREF="manual.html#2918"><STRONG>TaoAppSetMonitor()</STRONG></A>
<DT><A NAME="tex2html48"
 HREF="manual.html#2902"><STRONG>TaoAppSetObjectiveAndGradientRoutine()</STRONG></A>
<DT><A NAME="tex2html45"
 HREF="manual.html#2899"><STRONG>TaoAppSetObjectiveRoutine()</STRONG></A>
<DT><A NAME="tex2html8"
 HREF="manual.html#693"><STRONG>TaoCreate()</STRONG></A>
<DT><A NAME="tex2html10"
 HREF="manual.html#695"><STRONG>TaoDestroy()</STRONG></A>
<DT><A NAME="tex2html7"
 HREF="manual.html#692"><STRONG>TaoFinalize()</STRONG></A>
<DT><A NAME="tex2html20"
 HREF="manual.html#705"><STRONG>TaoGetGradient()</STRONG></A>
<DT><A NAME="tex2html67"
 HREF="manual.html#2921"><STRONG>TaoGetGradientVec()</STRONG></A>
<DT><A NAME="tex2html19"
 HREF="manual.html#704"><STRONG>TaoGetSolution()</STRONG></A>
<DT><A NAME="tex2html18"
 HREF="manual.html#703"><STRONG>TaoGetSolutionStatus()</STRONG></A>
<DT><A NAME="tex2html68"
 HREF="manual.html#2922"><STRONG>TaoGetVariableBoundVecs()</STRONG></A>
<DT><A NAME="tex2html5"
 HREF="manual.html#690"><STRONG>TaoInitialize()</STRONG></A>
<DT><A NAME="tex2html81"
 HREF="manual.html#3382"><STRONG>TaoSetConvergenceTest()</STRONG></A>
<DT><A NAME="tex2html13"
 HREF="manual.html#698"><STRONG>TaoSetGradientTolerances()</STRONG></A>
<DT><A NAME="tex2html83"
 HREF="manual.html#3384"><STRONG>TaoSetLineSearch()</STRONG></A>
<DT><A NAME="tex2html17"
 HREF="manual.html#702"><STRONG>TaoSetMaximumFunctionEvaluations()</STRONG></A>
<DT><A NAME="tex2html16"
 HREF="manual.html#701"><STRONG>TaoSetMaximumIterates()</STRONG></A>
<DT><A NAME="tex2html9"
 HREF="manual.html#694"><STRONG>TaoSetMethod()</STRONG></A>
<DT><A NAME="tex2html63"
 HREF="manual.html#2917"><STRONG>TaoSetMonitor()</STRONG></A>
<DT><A NAME="tex2html70"
 HREF="manual.html#2924"><STRONG>TaoSetOptions()</STRONG></A>
<DT><A NAME="tex2html11"
 HREF="manual.html#696"><STRONG>TaoSetTolerances()</STRONG></A>
<DT><A NAME="tex2html15"
 HREF="manual.html#700"><STRONG>TaoSetTrustRegionTolerance</STRONG></A>
<DT><A NAME="tex2html66"
 HREF="manual.html#2920"><STRONG>TaoSetupApplicationSolver()</STRONG></A>
<DT><A NAME="tex2html59"
 HREF="manual.html#2913"><STRONG>TaoSetVariableBoundsRoutine</STRONG></A>
<DT><A NAME="tex2html71"
 HREF="manual.html#2925"><STRONG>TaoSolveApplication()</STRONG></A>
<DT><A NAME="tex2html31"
 HREF="manual.html#1363"><STRONG>trust region</STRONG></A>
<A NAME="tex2html35"
 HREF="manual.html#1366">, <STRONG><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.gif"></STRONG></A>
<A NAME="tex2html14"
 HREF="manual.html#699">, <STRONG><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.gif"></STRONG></A>
<DT><A NAME="tex2html72"
 HREF="manual.html#2926"><STRONG>vectors</STRONG></A>
</DL>

<A NAME="sec:index"></A>
<P>

<H2><A NAME="SECTION00900000000000000000">
Bibliography</A>
</H2><DL COMPACT><DD><P></P><DT><A NAME="armijo:minimization">1</A>
<DD>
L.&nbsp;Armijo.
<BR>Minimization of functions having Lipschitz-continuous first partial
  derivatives.
<BR><EM>Pacific Journal of Mathematics</EM>, 16:1-3, 1966.

<P></P><DT><A NAME="petsc-web-page">2</A>
<DD>
Satish Balay, William&nbsp;D. Gropp, Lois&nbsp;Curfman McInnes, and Barry&nbsp;F. Smith.
<BR>PETSc Web page.
<BR>See <TT><A NAME="tex2html84"
  HREF="http://www.mcs.anl.gov/petsc">http://www.mcs.anl.gov/petsc</A></TT>.

<P></P><DT><A NAME="petsc">3</A>
<DD>
Satish Balay, William&nbsp;D. Gropp, Lois&nbsp;Curfman McInnes, and Barry&nbsp;F. Smith.
<BR>Efficient management of parallelism in object oriented numerical
  software libraries.
<BR>In E.&nbsp;Arge, A.&nbsp;M. Bruaset, and H.&nbsp;P. Langtangen, editors, <EM>Modern
  Software Tools in Scientific Computing</EM>, pages 163-202. Birkhauser Press,
  1997.

<P></P><DT><A NAME="petsc-user-ref">4</A>
<DD>
Satish Balay, William&nbsp;D. Gropp, Lois&nbsp;Curfman McInnes, and Barry&nbsp;F. Smith.
<BR>PETSc 2.0 users manual.
<BR>Technical Report ANL-95/11 - Revision 2.1.0, Argonne National
  Laboratory, Apr 2001.

<P></P><DT><A NAME="CGT">5</A>
<DD>
A.&nbsp;R. Conn, N.&nbsp;I.&nbsp;M. Gould, and Ph.&nbsp;L. Toint.
<BR><EM>Trust-Region Methods</EM>.
<BR>SIAM, Philadelphia, Pennsylvania, 2000.

<P></P><DT><A NAME="cottle:nonlinear">6</A>
<DD>
R.&nbsp;W. Cottle.
<BR><EM>Nonlinear programs with positively bounded Jacobians</EM>.
<BR>PhD thesis, Department of Mathematics, University of California,
  Berkeley, California, 1964.

<P></P><DT><A NAME="deluca.facchinei.ea:semismooth">7</A>
<DD>
T.&nbsp;De&nbsp;Luca, F.&nbsp;Facchinei, and C.&nbsp;Kanzow.
<BR>A semismooth equation approach to the solution of nonlinear
  complementarity problems.
<BR><EM>Mathematical Programming</EM>, 75:407-439, 1996.

<P></P><DT><A NAME="facchinei.fischer.ea:semismooth">8</A>
<DD>
F.&nbsp;Facchinei, A.&nbsp;Fischer, and C.&nbsp;Kanzow.
<BR>A semismooth Newton method for variational inequalities: The case
  of box constraints.
<BR>In M.&nbsp;C. Ferris and J.&nbsp;S. Pang, editors, <EM>Complementarity and
  Variational Problems: State of the Art</EM>, pages 76-90, Philadelphia,
  Pennsylvania, 1997. SIAM Publications.

<P></P><DT><A NAME="ferris.pang:engineering">9</A>
<DD>
M.&nbsp;C. Ferris and J.&nbsp;S. Pang.
<BR>Engineering and economic applications of complementarity problems.
<BR><EM>SIAM Review</EM>, 39:669-713, 1997.

<P></P><DT><A NAME="fischer:special">10</A>
<DD>
A.&nbsp;Fischer.
<BR>A special Newton-type optimization method.
<BR><EM>Optimization</EM>, 24:269-284, 1992.

<P></P><DT><A NAME="grippo.lampariello.ea:nonmonotone">11</A>
<DD>
L.&nbsp;Grippo, F.&nbsp;Lampariello, and S.&nbsp;Lucidi.
<BR>A nonmonotone line search technique for Newton's method.
<BR><EM>SIAM Journal on Numerical Analysis</EM>, 23:707-716, 1986.

<P></P><DT><A NAME="mpich-web-page">12</A>
<DD>
William Gropp and Ewing Lusk.
<BR>MPICH Web page.
<BR><TT><A NAME="tex2html85"
  HREF="http://www.mcs.anl.gov/mpi/mpich">http://www.mcs.anl.gov/mpi/mpich</A></TT>.

<P></P><DT><A NAME="using-mpi">13</A>
<DD>
William Gropp, Ewing Lusk, and Anthony Skjellum.
<BR><EM>Using MPI: Portable Parallel Programming with the Message
  Passing Interface</EM>.
<BR>MIT Press, 1994.

<P></P><DT><A NAME="huang.pang:option">14</A>
<DD>
J.&nbsp;Huang and J.&nbsp;S. Pang.
<BR>Option pricing and linear complementarity.
<BR><EM>Journal of Computational Finance</EM>, 2:31-60, 1998.

<P></P><DT><A NAME="bs-user-ref">15</A>
<DD>
Mark&nbsp;T. Jones and Paul&nbsp;E. Plassmann.
<BR>BlockSolve95 users manual: Scalable library software for the
  parallel solution of sparse linear systems.
<BR>Technical Report ANL-95/48, Argonne National Laboratory, December
  1995.

<P></P><DT><A NAME="karush:minima">16</A>
<DD>
W.&nbsp;Karush.
<BR>Minima of functions of several variables with inequalities as side
  conditions.
<BR>Master's thesis, Department of Mathematics, University of Chicago,
  1939.

<P></P><DT><A NAME="kuhn.tucker:nonlinear">17</A>
<DD>
H.&nbsp;W. Kuhn and A.&nbsp;W. Tucker.
<BR>Nonlinear programming.
<BR>In J.&nbsp;Neyman, editor, <EM>Proceedings of the Second Berkeley
  Symposium on Mathematical Statistics and Probability</EM>, pages 481-492.
  University of California Press, Berkeley and Los Angeles, 1951.

<P></P><DT><A NAME="lin_c3">18</A>
<DD>
C.-J. Lin and J.&nbsp;J. Mor&#233;.
<BR>Newton's method for large bound-constrained optimization problems.
<BR><EM>SIOPT</EM>, 9(4):1100-1127, 1999.

<P></P><DT><A NAME="mifflin:semismooth">19</A>
<DD>
R.&nbsp;Mifflin.
<BR>Semismooth and semiconvex functions in constrained optimization.
<BR><EM>SIAM Journal on Control and Optimization</EM>, 15:957-972, 1977.

<P></P><DT><A NAME="more-toraldo">20</A>
<DD>
Jorge&nbsp;J. Mor&#233; and G.&nbsp;Toraldo.
<BR>On the solution of large quadratic programming problems with bound
  constraints.
<BR><EM>SIOPT</EM>, 1:93-113, 1991.

<P></P><DT><A NAME="MPI-final">21</A>
<DD>
MPI: A message-passing interface standard.
<BR><EM>International J. Supercomputing Applications</EM>, 8(3/4), 1994.

<P></P><DT><A NAME="munson.facchinei.ea:semismooth">22</A>
<DD>
T.&nbsp;S. Munson, F.&nbsp;Facchinei, M.&nbsp;C. Ferris, A.&nbsp;Fischer, and C.&nbsp;Kanzow.
<BR>The semismooth algorithm for large scale complementarity problems.
<BR><EM>INFORMS Journal on Computing</EM>, forthcoming, 2001.

<P></P><DT><A NAME="nash:equilibrium">23</A>
<DD>
J.&nbsp;F. Nash.
<BR>Equilibrium points in N-person games.
<BR><EM>Proceedings of the National Academy of Sciences</EM>, 36:48-49,
  1950.

<P></P><DT><A NAME="nelder.mead:simplex">24</A>
<DD>
J.&nbsp;A. Nelder and R.&nbsp;Mead.
<BR>A simplex method for function minimization.
<BR><EM>Computer Journal</EM>, 7:308-313, 1965.

<P></P><DT><A NAME="NW99">25</A>
<DD>
Jorge Nocedal and Stephen&nbsp;J. Wright.
<BR><EM>Numerical Optimization</EM>.
<BR>Springer-Verlag, New York, 1999.

<P></P><DT><A NAME="qi:convergence">26</A>
<DD>
L.&nbsp;Qi.
<BR>Convergence analysis of some algorithms for solving nonsmooth
  equations.
<BR><EM>Mathematics of Operations Research</EM>, 18:227-244, 1993.

<P></P><DT><A NAME="qi.sun:nonsmooth">27</A>
<DD>
L.&nbsp;Qi and J.&nbsp;Sun.
<BR>A nonsmooth version of Newton's method.
<BR><EM>Mathematical Programming</EM>, 58:353-368, 1993.
</DL>

<P>

<H1><A NAME="SECTION001000000000000000000">
About this document ...</A>
</H1>
 <P>
This document was generated using the
<A HREF="http://www.latex2html.org/"><STRONG>LaTeX</STRONG>2<tt>HTML</tt></A> translator Version 2008 (1.71)
<P>
Copyright &#169; 1993, 1994, 1995, 1996,
Nikos Drakos, 
Computer Based Learning Unit, University of Leeds.
<BR>Copyright &#169; 1997, 1998, 1999,
<A HREF="http://www.maths.mq.edu.au/~ross/">Ross Moore</A>, 
Mathematics Department, Macquarie University, Sydney.
<P>
The command line arguments were: <BR>
 <STRONG>latex2html</STRONG> <TT>-no_math -image_type gif -reuse 0 -split 0 -local_icons manual</TT>
<P>
The translation was initiated by Jason Sarich on 2011-09-15
<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive" SRC="nx_grp_g.gif"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_g.gif"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev_g.gif">   
<BR></DIV>
<!--End of Navigation Panel-->
<ADDRESS>
Jason Sarich
2011-09-15
</ADDRESS>
</BODY>
</HTML>
